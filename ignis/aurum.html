<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ignis.aurum API documentation</title>
<meta name="description" content="`ignis.aurum.Aurum` instances manage the results of topic modelling runs, and provide
methods for exploring and iterating over them." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
</header>
<section id="section-intro">
<p><code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> instances manage the results of topic modelling runs, and provide
methods for exploring and iterating over them.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
`ignis.aurum.Aurum` instances manage the results of topic modelling runs, and provide
methods for exploring and iterating over them.
&#34;&#34;&#34;

import bz2
import copy
import json
import pathlib
import pickle
import pprint
import tempfile

import ignis.labeller.tomotopy
import ignis.vis.pyldavis


class Aurum:
    &#34;&#34;&#34;
    `Aurum` objects bring together the public APIs for `ignis` models, automated
    labellers, and visualisation data providers, while also providing general
    save/load functionality.

    **NOTE**: All topic IDs retrieved from `Aurum` instances are 1-indexed rather than
    0-indexed. So a model with 5 topics has topic IDs `[1, 2, 3, 4, 5]` and not
    `[0, 1, 2, 3, 4]`.

    This is for easier matching against pyLDAvis visualisations, and for easier usage
    by non-technical users.

    Parameters
    ----------
    ignis_model: ignis.models.base.BaseModel
        The specific `ignis` model used to generate this `Aurum` object.
    &#34;&#34;&#34;

    def __init__(self, ignis_model):
        self.ignis_model = ignis_model
        self.model_type = ignis_model.model_type
        self.model_options = ignis_model.options

        # Grab a reference to the CorpusSlice object so that we can use its methods
        # directly
        self.corpus_slice = ignis_model.corpus_slice

        # Aurum objects also optionally have cached labeller and visualisation data
        # objects
        self.labeller = None

        self.vis_type = None
        self.vis_options = None
        self.vis_data = None

    def save(self, filename):
        &#34;&#34;&#34;
        Saves the `Aurum` object, including its associated `ignis.models` model,
        to the given file.
        Essentially uses a bz2-compressed Pickle format.

        Also attempts to save any cached visualisation data, but will omit any
        initialised automated labeller (since labellers are probably not pickle-able).

        We recommend using _.aurum_ as the canonical file extension, but this is not
        strictly enforced by the library.

        Parameters
        ----------
        filename: str or pathlib.Path
            File to save the model to.
        &#34;&#34;&#34;
        filename = pathlib.Path(filename)

        # Copy the Ignis model, separate the external library&#39;s model out, pickle
        # everything together
        # (The model objects created by external libraries might not be pickle-able)
        external_model = self.ignis_model.model
        self.ignis_model.model = None
        save_model = copy.deepcopy(self.ignis_model)

        with tempfile.TemporaryDirectory() as tmpdir:
            tmp_model_file = pathlib.Path(tmpdir) / &#34;save_model.bin&#34;
            # We assume that the external library&#39;s model object provides a `.save()`
            # method that takes the filename as a string
            tmp_model_file = str(tmp_model_file)
            external_model.save(tmp_model_file)
            with open(tmp_model_file, &#34;rb&#34;) as fp:
                external_model_bytes = fp.read()

        save_object = {
            &#34;save_model&#34;: save_model,
            &#34;model_type&#34;: save_model.model_type,
            &#34;external_model_bytes&#34;: external_model_bytes,
            # We should also be able to save any cached visualisation data, but the
            # labeller is probably not pickle-able.
            &#34;vis_type&#34;: self.vis_type,
            &#34;vis_options&#34;: self.vis_options,
            &#34;vis_data&#34;: self.vis_data,
        }

        with bz2.open(filename, &#34;wb&#34;) as fp:
            pickle.dump(save_object, fp)

        self.ignis_model.model = external_model

    # =================================================================================
    # Topic Model
    # (Default arguments are defined by the models themselves, in case different
    # values work better with different models)
    def get_num_topics(self):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_num_topics()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_num_topics()

    def get_topic_words(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_topic_words()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_topic_words(*args, **kwargs)

    def get_topic_documents(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_topic_documents()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_topic_documents(*args, **kwargs)

    def get_document_topics(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_document_topics()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_document_topics(*args, **kwargs)

    def get_document_top_topic(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_document_top_topic()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_document_top_topic(*args, **kwargs)

    def get_coherence(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_coherence()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_coherence(*args, **kwargs)

    # =================================================================================
    # Corpus Slice
    @property
    def document_ids(self):
        &#34;&#34;&#34;
        Get the IDs of all the `ignis.corpus.Document` objects that are covered by this
        `ignis` model.

        Returns
        -------
        iterable of uuid.UUID
        &#34;&#34;&#34;
        return list(self.corpus_slice.document_ids)

    def get_document(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.corpus.CorpusSlice.get_document()`.
        &#34;&#34;&#34;
        return self.corpus_slice.get_document(*args, **kwargs)

    def slice_by_ids(self, doc_ids, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by the given `ignis.corpus.Document` IDs.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_ids()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_ids(doc_ids)

    def slice_by_token(self, token, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by the given token.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_token()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_token(token)

    def slice_by_tokens(self, tokens, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by tokens.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_tokens()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_tokens(tokens)

    def slice_without_token(self, token, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
        that contain the given token.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_without_token()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_without_token(token)

    def slice_without_tokens(self, tokens, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
        that contain any of the given tokens.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_without_tokens()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_without_tokens(tokens)

    def slice_by_text_string(self, text_string, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by the given text string.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_text_string()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_text_string(text_string)

    def slice_by_text_strings(self, text_strings, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by the given text strings.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_text_strings()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_text_strings(text_strings)

    def slice_without_text_string(self, text_string, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
        that contain the given text string.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_without_text_string()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_without_text_string(text_string)

    def slice_without_text_strings(self, text_strings, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
        that contain any of the given text strings.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_without_text_strings()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_without_text_strings(text_strings)

    def slice_filter(self, filter_fn, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset using some custom `filter_fn`.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_filter()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_filter(filter_fn)

    # =================================================================================
    # Automated Labeller
    def init_labeller(self, labeller_type, **labeller_options):
        &#34;&#34;&#34;
        Trains an automated `ignis.labeller` for this `Aurum` object.

        Parameters
        ----------
        labeller_type: {&#34;tomotopy&#34;}
            String denoting the labeller type.
        **labeller_options
            Keyword arguments that are passed to the constructor for the given
            labeller type.
        &#34;&#34;&#34;
        if labeller_type == &#34;tomotopy&#34;:
            self.labeller = ignis.labeller.tomotopy.TomotopyLabeller(
                self.ignis_model.model, **labeller_options
            )
        else:
            raise ValueError(f&#34;Unknown labeller type: &#39;{labeller_type}&#39;&#34;)

    def get_topic_labels(self, topic_id, top_n):
        &#34;&#34;&#34;
        See `ignis.labeller.tomotopy.TomotopyLabeller.get_topic_labels()`.
        &#34;&#34;&#34;
        if self.labeller is None:
            raise RuntimeError(
                &#34;There is no labeller instantiated for this Aurum object. &#34;
                &#34;Use `.init_labeller()` to prepare one.&#34;
            )
        return self.labeller.get_topic_labels(topic_id, top_n)

    # =================================================================================
    # Visualisation Data
    # TODO: Move `vis_data` into a full visualisation object, like the labeller/model?
    def init_vis(self, vis_type, force=False, **vis_options):
        &#34;&#34;&#34;
        Prepares the visualisation data for this `Aurum` object in the specified
        format.

        Parameters
        ----------
        vis_type: {&#34;pyldavis&#34;, &#34;clear&#34;}
            String denoting the visualisation type.  Passing `&#34;clear&#34;` will remove
            any existing visualisation data.
        force: bool, optional
            Forces recalculation of `self.vis_data`, if it already exists.
        **vis_options
            Keyword arguments that are passed to the constructor for the given
            visualisation type.
        &#34;&#34;&#34;
        if vis_type == &#34;clear&#34;:
            self.vis_type = None
            self.vis_options = None
            self.vis_data = None
        elif vis_type == &#34;pyldavis&#34;:
            if self.vis_data is not None and not force:
                raise RuntimeError(
                    f&#34;Visualisation data already exists for this Aurum object &#34;
                    f&#34;(type: &#39;{self.vis_type}&#39;). &#34;
                    f&#34;Pass `force=True` to force recalculation.&#34;
                )

            self.vis_type = vis_type
            self.vis_options = vis_options
            self.vis_data = ignis.vis.pyldavis.prepare_data(
                self.ignis_model.model, **vis_options
            )
        else:
            raise ValueError(f&#34;Unknown visualisation type: &#39;{vis_type}&#39;&#34;)

    def get_vis_data(self):
        &#34;&#34;&#34;
        Returns the prepared visualisation data for this model, if any.

        Different visualisation classes may have different ways of storing and
        representing this data.
        &#34;&#34;&#34;
        if self.vis_data is None:
            raise RuntimeError(
                &#34;There is no visualisation data instantiated for this Aurum object. &#34;
                &#34;Use `.init_vis()` to prepare it.&#34;
            )
        return self.vis_data

    def show_visualisation(self, **kwargs):
        &#34;&#34;&#34;
        Displays the prepared visualisation for this model.

        Presumes that the `ignis.vis` class returns a situation-appropriate format
        (e.g., for display in a Jupyter notebook)

        Parameters
        ----------
        **kwargs
            Passed through to the visualisation module.

        Returns
        -------
        The output of the `show_visualisation` method of the relevant `ignis.vis` class.
        &#34;&#34;&#34;
        vis_data = self.get_vis_data()

        if self.vis_type == &#34;pyldavis&#34;:
            return ignis.vis.pyldavis.show_visualisation(vis_data, **kwargs)
        else:
            raise RuntimeError(f&#34;Unknown saved visualisation type: &#39;{self.vis_type}&#39;&#34;)

    def get_visualisation_html(self, **kwargs):
        &#34;&#34;&#34;
        Gets the prepared visualisation for this model as a raw HTML string.

        Parameters
        ----------
        **kwargs
            Passed through to the visualisation module.

        Returns
        -------
        The output of the `get_visualisation_html` method of the relevant `ignis.vis`
        class.
        &#34;&#34;&#34;
        vis_data = self.get_vis_data()

        if self.vis_type == &#34;pyldavis&#34;:
            return ignis.vis.pyldavis.get_visualisation_html(vis_data, **kwargs)
        else:
            raise RuntimeError(f&#34;Unknown saved visualisation type: &#39;{self.vis_type}&#39;&#34;)

    def export_visualisation(self, folder, use_cdn=True):
        &#34;&#34;&#34;
        Exports the visualisation prepared for this `Aurum` object as a standalone
        webpage to the given folder.

        If `use_cdn` is `True` (the default case), only a single HTML file will be
        generated, and additional JS/CSS sources will be loaded from a CDN instead.

        Otherwise, the additional JS/CSS sources will be exported directly into the
        target folder together with the main visualisation file -- Be sure to include
        the entire exported folder when moving it to a different location for display
        (e.g., on a PC with no internet access).

        Parameters
        ----------
        folder: str or pathlib.Path
            The folder to export the visualisation to.
        use_cdn: bool, optional
            If True, will save a single HTML file and attempt to load additional JS/CSS
            sources from a CDN instead.
        &#34;&#34;&#34;
        vis_data = self.get_vis_data()

        # Assuming the `vis_data` get is successful, we should have a valid record of
        # the `vis_type` as well.
        if self.vis_type == &#34;pyldavis&#34;:
            ignis.vis.pyldavis.export_visualisation(vis_data, folder, use_cdn)
        else:
            raise RuntimeError(f&#34;Unknown saved visualisation type: &#39;{self.vis_type}&#39;&#34;)

    # =================================================================================
    # Jupyter widgets
    def nb_explore_topics(
        self,
        top_words=30,
        top_labels=15,
        doc_sort_key=None,
        display_fn=None,
        max_display_length=50000,
        metadata_full_doc_link=&#34;filename&#34;,
    ):
        &#34;&#34;&#34;
        Convenience function that creates an interactive Jupyter notebook widget for
        exploring the topics and `ignis.corpus.Document` objects tracked by this model.

        By default, `ignis.corpus.Document` objects are displayed in decreasing order
        of probability for each specified topic, but a custom sorting function can be
        passed via `doc_sort_key` as well.

        Suggested topic labels will be shown if the model has a labeller initialised.

        Parameters
        ----------
        top_words: int, optional
            The top `n` most probable terms for each topic to show.
        top_labels: int, optional
            The top `n` most probable labels for each topic to show.

            Will have no effect if the model does not have a labeller initialised.
        doc_sort_key: fn, optional
            If specified, will sort `ignis.corpus.Document` objects for each topic
            using this key when displaying them.
        display_fn: fn, optional
            Custom display function that receives an individual
            `ignis.corpus.Document` as input, and should display the
            `ignis.corpus.Document` in human-readable form as a side effect.

            If unset, will assume that the human-readable representation of the
            `ignis.corpus.Document` is in HTML format and display it accordingly.
        max_display_length: int, optional
            Maximum length (in characters) to display from the
            `ignis.corpus.Document` object&#39;s human-readable representation.  If the
            `ignis.corpus.Document` object&#39;s human-readable representation is longer
            than this limit, a link will be generated to view the full human-readable
            representation in a new window.

            No effect if `display_fn` is set.
        metadata_full_doc_link: str, optional
            If `max_display_length` is exceeded, this key is used to get the path to
            the full human-readable representation from the `Document` object&#39;s
            metadata dictionary.

            No effect if `display_fn` is set.
        &#34;&#34;&#34;
        import ipywidgets
        from IPython.core.display import display, HTML
        import ignis.util.jupyter_styles

        # Set up widget styling
        # noinspection PyTypeChecker
        display(HTML(ignis.util.jupyter_styles.jupyter_output_style))

        # Per topic info
        def show_topic(topic_id=1):
            # Top tokens
            words = &#34;, &#34;.join(
                word
                for word, probability in self.get_topic_words(topic_id, top_n=top_words)
            )
            print(f&#34;Top tokens:\n{words}&#34;)

            # Labels
            if self.labeller is not None:
                labels = &#34;, &#34;.join(
                    label
                    for label, score in self.get_topic_labels(
                        topic_id, top_n=top_labels
                    )
                )
                print(f&#34;\nSuggested labels:\n{labels}&#34;)

            top_n_header = ipywidgets.Output()
            # noinspection PyTypeChecker
            display(top_n_header)

            # Topic documents -- `within_top_n`
            def show_topic_doc(within_top_n=1):
                with top_n_header:
                    top_n_header.clear_output(wait=True)
                    # noinspection PyTypeChecker
                    display(
                        HTML(
                            f&#34;&lt;h4&gt;Documents with Topic {topic_id} in the top &#34;
                            f&#34;{within_top_n} topic(s)&lt;/h4&gt;&#34;
                        )
                    )

                # Grab the documents that match the params passed, sorted by topic
                # probability in descending order
                topic_probs = self.get_topic_documents(topic_id, within_top_n)
                topic_probs = sorted(topic_probs, key=lambda x: x[1], reverse=True)

                topic_docs = [doc_id for doc_id, prob in topic_probs]

                if len(topic_docs) == 0:
                    print(
                        &#34;No documents matching the given topic parameters. &#34;
                        &#34;Try increasing `n`, or reducing the number of total topics &#34;
                        &#34;and retraining the model.&#34;
                    )
                    return

                topic_docs = [self.get_document(doc_id) for doc_id in topic_docs]

                if doc_sort_key is not None:
                    topic_docs = sorted(topic_docs, key=doc_sort_key)

                # Show actual document
                def show_doc(index=1):
                    # Start `index` from 1 for user-friendliness
                    print(f&#34;[Total documents: {len(topic_docs)}]\n&#34;)
                    doc = topic_docs[index - 1]

                    if display_fn is None:
                        # Default HTML display
                        print(f&#34;ID: {doc.id}&#34;)
                        if &#34;filename&#34; in doc.metadata:
                            print(f&#34;Filename: {doc.metadata[&#39;filename&#39;]}&#34;)
                        if &#34;txt_filename&#34; in doc.metadata:
                            print(f&#34;Processed: {doc.metadata[&#39;txt_filename&#39;]}&#34;)

                        if &#34;sender&#34; in doc.metadata:
                            print(f&#34;Sender: {doc.metadata[&#39;sender&#39;]}&#34;)
                        if &#34;recipients&#34; in doc.metadata:
                            recipients = doc.metadata[&#34;recipients&#34;]

                            # Truncate long recipient lists for display
                            # (TODO: Make this optional?)
                            if len(recipients) &gt; 5:
                                recipients = recipients[:5] + [&#34;...&#34;]

                            print(f&#34;Recipients:\n{json.dumps(recipients, indent=2)}&#34;)

                        # Jupyter notebooks will interpret anything between $ signs
                        # as LaTeX formulae when rendering HTML output, so we need to
                        # replace them with escaped $ signs (only in Jupyter
                        # environments)
                        display_str = doc.display_str.replace(&#34;$&#34;, r&#34;\$&#34;)

                        # Length check
                        if len(display_str) &gt; max_display_length:
                            display_str = (
                                f&#34;&lt;p&gt;&#34;
                                f&#34;&lt;b&gt;Document too long to display in full - &#34;
                                f&#34;Showing first {max_display_length} &#34;
                                f&#34;characters.&lt;/b&gt;&#34;
                                f&#34;&lt;/p&gt;&#34;
                                f&#34;&lt;p&gt;&#34;
                                f&#34;&lt;a href=&#34;
                                f&#34;&#39;{doc.metadata[metadata_full_doc_link]}&#39; &#34;
                                f&#34;target=&#39;_blank&#39;&gt;&#34;
                                f&#34;Click here&#34;
                                f&#34;&lt;/a&gt; to open the full document in a new &#34;
                                f&#34;tab/window.&#34;
                                f&#34;&lt;/p&gt;&#34;
                                f&#34;&lt;hr/&gt;&#34; + display_str[:max_display_length]
                            )

                        # noinspection PyTypeChecker
                        display(HTML(display_str))
                    else:
                        # User-provided display function
                        display_fn(doc)
                    print()
                    print(
                        &#34;Top 10 document topics (in descending order of probability):&#34;
                    )
                    top_topics = self.get_document_topics(doc.id, 10)
                    # Use a more readable format
                    for topic, prob in top_topics:
                        print(f&#34;Topic {topic}: {prob*100:.2f}%&#34;)

                # Control and output widgets for the document viewer
                slider = ipywidgets.IntSlider(
                    description=&#34;Document&#34;,
                    min=1,
                    max=len(topic_docs),
                    continuous_update=False,
                    layout=ignis.util.jupyter_styles.slider_layout,
                    style=ignis.util.jupyter_styles.slider_style,
                )
                text = ipywidgets.BoundedIntText(
                    min=1,
                    max=len(topic_docs),
                    layout=ignis.util.jupyter_styles.slider_text_layout,
                )
                ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
                ui = ipywidgets.HBox([slider, text])
                out = ipywidgets.interactive_output(show_doc, {&#34;index&#34;: slider})
                # noinspection PyTypeChecker
                display(ui, out)

            # Control and output widgets for the document top-n-topics viewer
            slider = ipywidgets.IntSlider(
                description=&#34;No. of topics to consider per doc&#34;,
                min=1,
                max=self.get_num_topics(),
                continuous_update=False,
                layout=ignis.util.jupyter_styles.slider_layout,
                style=ignis.util.jupyter_styles.slider_style,
            )
            text = ipywidgets.BoundedIntText(
                min=1,
                max=self.get_num_topics(),
                layout=ignis.util.jupyter_styles.slider_text_layout,
            )
            ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
            ui = ipywidgets.HBox([slider, text])
            out = ipywidgets.interactive_output(
                show_topic_doc, {&#34;within_top_n&#34;: slider}
            )
            # noinspection PyTypeChecker
            display(ui, out)

        # Control and output widgets for the topic viewer
        slider = ipywidgets.IntSlider(
            description=&#34;Topic&#34;,
            min=1,
            max=self.get_num_topics(),
            continuous_update=False,
            layout=ignis.util.jupyter_styles.slider_layout,
            style=ignis.util.jupyter_styles.slider_style,
        )
        text = ipywidgets.BoundedIntText(
            min=1,
            max=self.get_num_topics(),
            layout=ignis.util.jupyter_styles.slider_text_layout,
        )
        ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
        ui = ipywidgets.HBox([slider, text])
        out = ipywidgets.interactive_output(show_topic, {&#34;topic_id&#34;: slider})
        # noinspection PyTypeChecker
        display(ui, out)

    # =================================================================================
    # Slicing and Iteration
    # Convenience functions that help with the exploring the Model-Corpus interface
    def slice_by_topics(self, topic_ids, within_top_n=1, ignore_topics=None):
        &#34;&#34;&#34;
        General form of `Aurum.slice_by_topic()`.

        Parameters
        ----------
        topic_ids: iterable of int
            The IDs of the topics to consider.
        within_top_n: int, optional
            How many of each `ignis.corpus.Document` object&#39;s top topics to consider.
        ignore_topics: iterable of int, optional
            Don&#39;t count any of these topics if they are within the top `n` for a
            `ignis.corpus.Document`.

            E.g., for a `ignis.corpus.Document` with top topics `[5, 1, 3, ...]`,
            setting `ignore_topics` to `[5]` will consider the document&#39;s top topics
            to be `[1, 3, ...]` instead.

        Returns
        -------
        ignis.corpus.CorpusSlice
        &#34;&#34;&#34;
        if ignore_topics is None:
            ignore_topics = []

        all_doc_ids = []
        for doc_id in self.document_ids:
            # This is a list of (&lt;topic&gt;, &lt;prob&gt;)
            doc_topics = self.get_document_topics(
                doc_id, within_top_n + len(ignore_topics)
            )
            doc_topics = sorted(doc_topics, key=lambda x: x[1], reverse=True)
            checked_topics = 0
            for topic, prob in doc_topics:
                if topic not in ignore_topics:
                    # We&#39;ve seen one more topic for this document
                    checked_topics += 1

                if checked_topics &gt; within_top_n:
                    # Exceeded the topic check limit for this document
                    break

                if topic in topic_ids:
                    # Add it and go to the next document, we&#39;re done here
                    all_doc_ids.append(doc_id)
                    break

        return self.slice_by_ids(all_doc_ids)

    def slice_by_topic(self, topic_id, within_top_n=1, ignore_topics=None):
        &#34;&#34;&#34;
        Convenience function to create a new `ignis.corpus.CorpusSlice` containing the
        `ignis.corpus.Document` objects that have the given topic as one of their top
        `n` topics under the current model.

        **NOTE**: `topic_id` is 1-indexed, not 0-indexed (i.e., it is in `range(1,
        len(topics) + 1)`).

        Parameters
        ----------
        topic_id: int
            The ID of the topic to consider.
        within_top_n: int, optional
            How many of each `ignis.corpus.Document` object&#39;s top topics to consider.
        ignore_topics: iterable of int, optional
            Don&#39;t count any of these topics if they are within the top `n` for a
            `ignis.corpus.Document`.

            E.g., for a `ignis.corpus.Document` with top topics `[5, 1, 3, ...]`,
            setting `ignore_topics` to `[5]` will consider the document&#39;s top topics
            to be `[1, 3, ...]` instead.

        Returns
        -------
        ignis.corpus.CorpusSlice
        &#34;&#34;&#34;
        return self.slice_by_topics([topic_id], within_top_n, ignore_topics)

    def retrain_model(
        self,
        corpus_slice=None,
        model_type=None,
        model_options=None,
        labeller_type=None,
        labeller_options=None,
        vis_type=None,
        vis_options=None,
    ):
        &#34;&#34;&#34;
        (Re-)trains a topic model over some `ignis.corpus.CorpusSlice`.

        If `model_type`, `labeller_type`, and/or `vis_type` are `None`, the saved
        options from this current `Aurum` object are carried over and used.

        If new `model_options`, `labeller_options`, and/or `vis_options` dictionaries
        are passed, they are _merged_ with the ones from this current `Aurum` object
        instead of replacing them outright.

        See `ignis.probat.train_model()` for more details on the various parameters.

        Parameters
        ----------
        corpus_slice: ignis.corpus.Corpus or ignis.corpus.CorpusSlice, optional
            The `ignis.corpus.CorpusSlice` to (re-)train the model for.
        model_type: str, optional
            The type of topic model to train.
        model_options: dict, optional
            If set, will be merged with this `Aurum` object&#39;s saved options.
        labeller_type: str, optional
            The type of automated labeller to train.
        labeller_options: dict, optional
            If set, will be merged with this `Aurum` object&#39;s saved options.
        vis_type: str, optional
            The type of visualisation to prepare.
        vis_options: dict, optional
            If set, will be merged with this `Aurum` object&#39;s saved options.

        Returns
        -------
        ignis.aurum.Aurum
            The results object for the newly-trained model, which can be used for
            further exploration and iteration.
        &#34;&#34;&#34;
        if corpus_slice is not None and len(corpus_slice) == 0:
            raise RuntimeError(&#34;Cannot retrain model on an empty CorpusSlice.&#34;)

        new_kwargs = {
            &#34;corpus_slice&#34;: corpus_slice or self.corpus_slice,
            &#34;model_type&#34;: model_type or self.model_type,
            &#34;vis_type&#34;: vis_type or self.vis_type,
        }

        # We can only look up current labeller settings if this object has a labeller
        # initialised in the first place
        if self.labeller is not None:
            if labeller_type is None:
                new_kwargs[&#34;labeller_type&#34;] = self.labeller.labeller_type
            if labeller_options is None:
                new_kwargs[&#34;labeller_options&#34;] = self.labeller.options

        # Merge option dictionaries, where available
        if model_options is not None:
            new_kwargs[&#34;model_options&#34;] = dict(self.model_options, **model_options)
        else:
            new_kwargs[&#34;model_options&#34;] = self.model_options

        if labeller_options is not None:
            if self.labeller is not None:
                new_kwargs[&#34;labeller_options&#34;] = dict(
                    self.labeller.options, **labeller_options
                )
            else:
                new_kwargs[&#34;labeller_options&#34;] = labeller_options

        if vis_options is not None:
            if self.vis_options is not None:
                new_kwargs[&#34;vis_options&#34;] = dict(self.vis_options, **vis_options)
            else:
                new_kwargs[&#34;vis_options&#34;] = vis_options
        else:
            new_kwargs[&#34;vis_options&#34;] = self.vis_options

        return ignis.probat.train_model(**new_kwargs)

    def resuggest_num_topics(
        self, corpus_slice=None, model_options=None, *args, **kwargs
    ):
        &#34;&#34;&#34;
        (Re-)suggests a possible number of topics for some
        `ignis.corpus.CorpusSlice`, using this `Aurum` object&#39;s saved options as
        defaults.

        If a new model options dict is passed, it will be _merged_ with the one from
        this current `Aurum` object instead of replacing it outright.

        All other parameters, including coherence calculation options, are passed
        through directly to `ignis.probat.suggest_num_topics()`.

        Parameters
        ----------
        corpus_slice: ignis.corpus.Corpus or ignis.corpus.CorpusSlice, optional
            The new slice to suggest a number of topics for.  If `None`, will use
            this `Aurum` object&#39;s current `ignis.corpus.CorpusSlice`.
        model_options: dict, optional
            Any options set here will be merged with the current model options.
        *args, **kwargs
            Passed on to `ignis.probat.suggest_num_topics()`.

        Returns
        -------
        int
            Suggested topic count.
        &#34;&#34;&#34;
        if corpus_slice is not None and len(corpus_slice) == 0:
            raise RuntimeError(&#34;Cannot retrain model on an empty CorpusSlice.&#34;)

        # The only options that are inherited directly from this `Aurum` instance are
        # `corpus_slice` and `model_options` (where appropriate)
        new_kwargs = {&#34;corpus_slice&#34;: corpus_slice or self.corpus_slice}

        # Merge option dictionaries, where available
        if model_options is not None:
            new_kwargs[&#34;model_options&#34;] = dict(self.model_options, **model_options)
        else:
            new_kwargs[&#34;model_options&#34;] = self.model_options

        # All other arguments can be passed straight to
        # `ignis.probat.suggest_num_topics()`, if set
        new_kwargs = dict(kwargs, **new_kwargs)

        return ignis.probat.suggest_num_topics(*args, **new_kwargs)


def load_results(filename):
    &#34;&#34;&#34;
    Loads an `ignis.aurum.Aurum` results object from the given file.

    Parameters
    ----------
    filename: str or pathlib.Path
        The file to load the `ignis.aurum.Aurum` object from.

    Returns
    -------
    ignis.aurum.Aurum
    &#34;&#34;&#34;
    with bz2.open(filename, &#34;rb&#34;) as fp:
        save_object = pickle.load(fp)

    # Rehydrate the Ignis/external models
    model_type = save_object[&#34;model_type&#34;]
    save_model = save_object[&#34;save_model&#34;]
    external_model_bytes = save_object[&#34;external_model_bytes&#34;]

    if model_type[:3] == &#34;tp_&#34;:
        # Tomotopy model
        external_model = _load_tomotopy_model(model_type, external_model_bytes)
    else:
        raise ValueError(f&#34;Unknown model type: &#39;{model_type}&#39;&#34;)

    save_model.model = external_model

    # Rehydrate the Aurum object
    aurum = Aurum(save_model)

    aurum.vis_type = save_object[&#34;vis_type&#34;]
    aurum.vis_options = save_object[&#34;vis_options&#34;]
    aurum.vis_data = save_object[&#34;vis_data&#34;]

    return aurum


def _load_tomotopy_model(model_type, model_bytes):
    &#34;&#34;&#34;
    Loads a Tomotopy model of the specified type from its binary representation.

    (All Tomotopy models are subclasses of tomotopy.LDAModel)

    Parameters
    ----------
    model_type: {&#34;tp_lda&#34;}
        String identifying the type of the saved Tomotopy model
    model_bytes: bytes
        The actual saved model

    Returns
    -------
    tp.LDAModel
    &#34;&#34;&#34;
    import ignis.models

    if model_type == &#34;tp_lda&#34;:
        return ignis.models.LDAModel.load_from_bytes(model_bytes)
    elif model_type == &#34;tp_hdp&#34;:
        return ignis.models.HDPModel.load_from_bytes(model_bytes)
    else:
        raise ValueError(f&#34;Unknown model type: &#39;{model_type}&#39;&#34;)


def show_visualisations(aurum_objects):
    &#34;&#34;&#34;
    Given some list of multiple `ignis.aurum.Aurum` objects that have initialised
    visualisation data, show them sequentially with a Jupyter notebook slider widget.

    Parameters
    ----------
    aurum_objects: iterable of `ignis.aurum.Aurum`
        The result `ignis.aurum.Aurum` objects to display visualisations for.
    &#34;&#34;&#34;
    import ipywidgets
    from IPython.core.display import display, HTML
    import ignis.util.jupyter_styles

    # Control widgets
    slider = ipywidgets.IntSlider(
        description=&#34;Visualisation:&#34;,
        min=1,
        max=len(aurum_objects),
        continuous_update=False,
        layout=ignis.util.jupyter_styles.slider_layout,
        style=ignis.util.jupyter_styles.slider_style,
    )
    text = ipywidgets.BoundedIntText(
        min=1,
        max=len(aurum_objects),
        layout=ignis.util.jupyter_styles.slider_text_layout,
    )
    ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))

    # Display function
    def show_vis(index=1):
        # `index` starts at 1 for user-friendliness
        aurum_object = aurum_objects[index - 1]

        header_html = f&#34;&lt;h2 style=&#39;margin-bottom: 1em;&#39;&gt;Visualisation {index}&lt;/h2&gt;&#34;
        vis_html = aurum_object.get_visualisation_html()

        # noinspection PyTypeChecker
        display(HTML(header_html + vis_html))

    # Show widgets
    ui = ipywidgets.HBox([slider, text])
    out = ipywidgets.interactive_output(show_vis, {&#34;index&#34;: slider})
    # noinspection PyTypeChecker
    display(ui, out)

    # Show the initial output (i.e., with index == 1).  We need to call it manually
    # here because some visualisations (e.g., pyLDAvis) will only be drawn if `out`
    # has already been made visible via `display()`.
    with out:
        out.clear_output(wait=True)
        show_vis()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ignis.aurum.load_results"><code class="name flex">
<span>def <span class="ident">load_results</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads an <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> results object from the given file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path</code></dt>
<dd>The file to load the <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_results(filename):
    &#34;&#34;&#34;
    Loads an `ignis.aurum.Aurum` results object from the given file.

    Parameters
    ----------
    filename: str or pathlib.Path
        The file to load the `ignis.aurum.Aurum` object from.

    Returns
    -------
    ignis.aurum.Aurum
    &#34;&#34;&#34;
    with bz2.open(filename, &#34;rb&#34;) as fp:
        save_object = pickle.load(fp)

    # Rehydrate the Ignis/external models
    model_type = save_object[&#34;model_type&#34;]
    save_model = save_object[&#34;save_model&#34;]
    external_model_bytes = save_object[&#34;external_model_bytes&#34;]

    if model_type[:3] == &#34;tp_&#34;:
        # Tomotopy model
        external_model = _load_tomotopy_model(model_type, external_model_bytes)
    else:
        raise ValueError(f&#34;Unknown model type: &#39;{model_type}&#39;&#34;)

    save_model.model = external_model

    # Rehydrate the Aurum object
    aurum = Aurum(save_model)

    aurum.vis_type = save_object[&#34;vis_type&#34;]
    aurum.vis_options = save_object[&#34;vis_options&#34;]
    aurum.vis_data = save_object[&#34;vis_data&#34;]

    return aurum</code></pre>
</details>
</dd>
<dt id="ignis.aurum.show_visualisations"><code class="name flex">
<span>def <span class="ident">show_visualisations</span></span>(<span>aurum_objects)</span>
</code></dt>
<dd>
<div class="desc"><p>Given some list of multiple <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> objects that have initialised
visualisation data, show them sequentially with a Jupyter notebook slider widget.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>aurum_objects</code></strong> :&ensp;<code>iterable</code> of <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code></dt>
<dd>The result <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> objects to display visualisations for.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_visualisations(aurum_objects):
    &#34;&#34;&#34;
    Given some list of multiple `ignis.aurum.Aurum` objects that have initialised
    visualisation data, show them sequentially with a Jupyter notebook slider widget.

    Parameters
    ----------
    aurum_objects: iterable of `ignis.aurum.Aurum`
        The result `ignis.aurum.Aurum` objects to display visualisations for.
    &#34;&#34;&#34;
    import ipywidgets
    from IPython.core.display import display, HTML
    import ignis.util.jupyter_styles

    # Control widgets
    slider = ipywidgets.IntSlider(
        description=&#34;Visualisation:&#34;,
        min=1,
        max=len(aurum_objects),
        continuous_update=False,
        layout=ignis.util.jupyter_styles.slider_layout,
        style=ignis.util.jupyter_styles.slider_style,
    )
    text = ipywidgets.BoundedIntText(
        min=1,
        max=len(aurum_objects),
        layout=ignis.util.jupyter_styles.slider_text_layout,
    )
    ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))

    # Display function
    def show_vis(index=1):
        # `index` starts at 1 for user-friendliness
        aurum_object = aurum_objects[index - 1]

        header_html = f&#34;&lt;h2 style=&#39;margin-bottom: 1em;&#39;&gt;Visualisation {index}&lt;/h2&gt;&#34;
        vis_html = aurum_object.get_visualisation_html()

        # noinspection PyTypeChecker
        display(HTML(header_html + vis_html))

    # Show widgets
    ui = ipywidgets.HBox([slider, text])
    out = ipywidgets.interactive_output(show_vis, {&#34;index&#34;: slider})
    # noinspection PyTypeChecker
    display(ui, out)

    # Show the initial output (i.e., with index == 1).  We need to call it manually
    # here because some visualisations (e.g., pyLDAvis) will only be drawn if `out`
    # has already been made visible via `display()`.
    with out:
        out.clear_output(wait=True)
        show_vis()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ignis.aurum.Aurum"><code class="flex name class">
<span>class <span class="ident">Aurum</span></span>
<span>(</span><span>ignis_model)</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> objects bring together the public APIs for <code><a title="ignis" href="index.html">ignis</a></code> models, automated
labellers, and visualisation data providers, while also providing general
save/load functionality.</p>
<p><strong>NOTE</strong>: All topic IDs retrieved from <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> instances are 1-indexed rather than
0-indexed. So a model with 5 topics has topic IDs <code>[1, 2, 3, 4, 5]</code> and not
<code>[0, 1, 2, 3, 4]</code>.</p>
<p>This is for easier matching against pyLDAvis visualisations, and for easier usage
by non-technical users.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ignis_model</code></strong> :&ensp;<code><a title="ignis.models.base.BaseModel" href="models/base.html#ignis.models.base.BaseModel">BaseModel</a></code></dt>
<dd>The specific <code><a title="ignis" href="index.html">ignis</a></code> model used to generate this <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Aurum:
    &#34;&#34;&#34;
    `Aurum` objects bring together the public APIs for `ignis` models, automated
    labellers, and visualisation data providers, while also providing general
    save/load functionality.

    **NOTE**: All topic IDs retrieved from `Aurum` instances are 1-indexed rather than
    0-indexed. So a model with 5 topics has topic IDs `[1, 2, 3, 4, 5]` and not
    `[0, 1, 2, 3, 4]`.

    This is for easier matching against pyLDAvis visualisations, and for easier usage
    by non-technical users.

    Parameters
    ----------
    ignis_model: ignis.models.base.BaseModel
        The specific `ignis` model used to generate this `Aurum` object.
    &#34;&#34;&#34;

    def __init__(self, ignis_model):
        self.ignis_model = ignis_model
        self.model_type = ignis_model.model_type
        self.model_options = ignis_model.options

        # Grab a reference to the CorpusSlice object so that we can use its methods
        # directly
        self.corpus_slice = ignis_model.corpus_slice

        # Aurum objects also optionally have cached labeller and visualisation data
        # objects
        self.labeller = None

        self.vis_type = None
        self.vis_options = None
        self.vis_data = None

    def save(self, filename):
        &#34;&#34;&#34;
        Saves the `Aurum` object, including its associated `ignis.models` model,
        to the given file.
        Essentially uses a bz2-compressed Pickle format.

        Also attempts to save any cached visualisation data, but will omit any
        initialised automated labeller (since labellers are probably not pickle-able).

        We recommend using _.aurum_ as the canonical file extension, but this is not
        strictly enforced by the library.

        Parameters
        ----------
        filename: str or pathlib.Path
            File to save the model to.
        &#34;&#34;&#34;
        filename = pathlib.Path(filename)

        # Copy the Ignis model, separate the external library&#39;s model out, pickle
        # everything together
        # (The model objects created by external libraries might not be pickle-able)
        external_model = self.ignis_model.model
        self.ignis_model.model = None
        save_model = copy.deepcopy(self.ignis_model)

        with tempfile.TemporaryDirectory() as tmpdir:
            tmp_model_file = pathlib.Path(tmpdir) / &#34;save_model.bin&#34;
            # We assume that the external library&#39;s model object provides a `.save()`
            # method that takes the filename as a string
            tmp_model_file = str(tmp_model_file)
            external_model.save(tmp_model_file)
            with open(tmp_model_file, &#34;rb&#34;) as fp:
                external_model_bytes = fp.read()

        save_object = {
            &#34;save_model&#34;: save_model,
            &#34;model_type&#34;: save_model.model_type,
            &#34;external_model_bytes&#34;: external_model_bytes,
            # We should also be able to save any cached visualisation data, but the
            # labeller is probably not pickle-able.
            &#34;vis_type&#34;: self.vis_type,
            &#34;vis_options&#34;: self.vis_options,
            &#34;vis_data&#34;: self.vis_data,
        }

        with bz2.open(filename, &#34;wb&#34;) as fp:
            pickle.dump(save_object, fp)

        self.ignis_model.model = external_model

    # =================================================================================
    # Topic Model
    # (Default arguments are defined by the models themselves, in case different
    # values work better with different models)
    def get_num_topics(self):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_num_topics()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_num_topics()

    def get_topic_words(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_topic_words()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_topic_words(*args, **kwargs)

    def get_topic_documents(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_topic_documents()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_topic_documents(*args, **kwargs)

    def get_document_topics(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_document_topics()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_document_topics(*args, **kwargs)

    def get_document_top_topic(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_document_top_topic()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_document_top_topic(*args, **kwargs)

    def get_coherence(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.models.base.BaseModel.get_coherence()`.
        &#34;&#34;&#34;
        return self.ignis_model.get_coherence(*args, **kwargs)

    # =================================================================================
    # Corpus Slice
    @property
    def document_ids(self):
        &#34;&#34;&#34;
        Get the IDs of all the `ignis.corpus.Document` objects that are covered by this
        `ignis` model.

        Returns
        -------
        iterable of uuid.UUID
        &#34;&#34;&#34;
        return list(self.corpus_slice.document_ids)

    def get_document(self, *args, **kwargs):
        &#34;&#34;&#34;
        See `ignis.corpus.CorpusSlice.get_document()`.
        &#34;&#34;&#34;
        return self.corpus_slice.get_document(*args, **kwargs)

    def slice_by_ids(self, doc_ids, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by the given `ignis.corpus.Document` IDs.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_ids()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_ids(doc_ids)

    def slice_by_token(self, token, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by the given token.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_token()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_token(token)

    def slice_by_tokens(self, tokens, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by tokens.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_tokens()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_tokens(tokens)

    def slice_without_token(self, token, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
        that contain the given token.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_without_token()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_without_token(token)

    def slice_without_tokens(self, tokens, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
        that contain any of the given tokens.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_without_tokens()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_without_tokens(tokens)

    def slice_by_text_string(self, text_string, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by the given text string.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_text_string()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_text_string(text_string)

    def slice_by_text_strings(self, text_strings, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by the given text strings.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_by_text_strings()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_by_text_strings(text_strings)

    def slice_without_text_string(self, text_string, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
        that contain the given text string.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_without_text_string()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_without_text_string(text_string)

    def slice_without_text_strings(self, text_strings, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
        that contain any of the given text strings.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_without_text_strings()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_without_text_strings(text_strings)

    def slice_filter(self, filter_fn, include_root=False):
        &#34;&#34;&#34;
        Slice the model&#39;s input dataset using some custom `filter_fn`.

        If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
        instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

        See `ignis.corpus.Corpus.slice_filter()` for more details.
        &#34;&#34;&#34;
        base_slice = self.corpus_slice
        if include_root:
            base_slice = base_slice.root

        return base_slice.slice_filter(filter_fn)

    # =================================================================================
    # Automated Labeller
    def init_labeller(self, labeller_type, **labeller_options):
        &#34;&#34;&#34;
        Trains an automated `ignis.labeller` for this `Aurum` object.

        Parameters
        ----------
        labeller_type: {&#34;tomotopy&#34;}
            String denoting the labeller type.
        **labeller_options
            Keyword arguments that are passed to the constructor for the given
            labeller type.
        &#34;&#34;&#34;
        if labeller_type == &#34;tomotopy&#34;:
            self.labeller = ignis.labeller.tomotopy.TomotopyLabeller(
                self.ignis_model.model, **labeller_options
            )
        else:
            raise ValueError(f&#34;Unknown labeller type: &#39;{labeller_type}&#39;&#34;)

    def get_topic_labels(self, topic_id, top_n):
        &#34;&#34;&#34;
        See `ignis.labeller.tomotopy.TomotopyLabeller.get_topic_labels()`.
        &#34;&#34;&#34;
        if self.labeller is None:
            raise RuntimeError(
                &#34;There is no labeller instantiated for this Aurum object. &#34;
                &#34;Use `.init_labeller()` to prepare one.&#34;
            )
        return self.labeller.get_topic_labels(topic_id, top_n)

    # =================================================================================
    # Visualisation Data
    # TODO: Move `vis_data` into a full visualisation object, like the labeller/model?
    def init_vis(self, vis_type, force=False, **vis_options):
        &#34;&#34;&#34;
        Prepares the visualisation data for this `Aurum` object in the specified
        format.

        Parameters
        ----------
        vis_type: {&#34;pyldavis&#34;, &#34;clear&#34;}
            String denoting the visualisation type.  Passing `&#34;clear&#34;` will remove
            any existing visualisation data.
        force: bool, optional
            Forces recalculation of `self.vis_data`, if it already exists.
        **vis_options
            Keyword arguments that are passed to the constructor for the given
            visualisation type.
        &#34;&#34;&#34;
        if vis_type == &#34;clear&#34;:
            self.vis_type = None
            self.vis_options = None
            self.vis_data = None
        elif vis_type == &#34;pyldavis&#34;:
            if self.vis_data is not None and not force:
                raise RuntimeError(
                    f&#34;Visualisation data already exists for this Aurum object &#34;
                    f&#34;(type: &#39;{self.vis_type}&#39;). &#34;
                    f&#34;Pass `force=True` to force recalculation.&#34;
                )

            self.vis_type = vis_type
            self.vis_options = vis_options
            self.vis_data = ignis.vis.pyldavis.prepare_data(
                self.ignis_model.model, **vis_options
            )
        else:
            raise ValueError(f&#34;Unknown visualisation type: &#39;{vis_type}&#39;&#34;)

    def get_vis_data(self):
        &#34;&#34;&#34;
        Returns the prepared visualisation data for this model, if any.

        Different visualisation classes may have different ways of storing and
        representing this data.
        &#34;&#34;&#34;
        if self.vis_data is None:
            raise RuntimeError(
                &#34;There is no visualisation data instantiated for this Aurum object. &#34;
                &#34;Use `.init_vis()` to prepare it.&#34;
            )
        return self.vis_data

    def show_visualisation(self, **kwargs):
        &#34;&#34;&#34;
        Displays the prepared visualisation for this model.

        Presumes that the `ignis.vis` class returns a situation-appropriate format
        (e.g., for display in a Jupyter notebook)

        Parameters
        ----------
        **kwargs
            Passed through to the visualisation module.

        Returns
        -------
        The output of the `show_visualisation` method of the relevant `ignis.vis` class.
        &#34;&#34;&#34;
        vis_data = self.get_vis_data()

        if self.vis_type == &#34;pyldavis&#34;:
            return ignis.vis.pyldavis.show_visualisation(vis_data, **kwargs)
        else:
            raise RuntimeError(f&#34;Unknown saved visualisation type: &#39;{self.vis_type}&#39;&#34;)

    def get_visualisation_html(self, **kwargs):
        &#34;&#34;&#34;
        Gets the prepared visualisation for this model as a raw HTML string.

        Parameters
        ----------
        **kwargs
            Passed through to the visualisation module.

        Returns
        -------
        The output of the `get_visualisation_html` method of the relevant `ignis.vis`
        class.
        &#34;&#34;&#34;
        vis_data = self.get_vis_data()

        if self.vis_type == &#34;pyldavis&#34;:
            return ignis.vis.pyldavis.get_visualisation_html(vis_data, **kwargs)
        else:
            raise RuntimeError(f&#34;Unknown saved visualisation type: &#39;{self.vis_type}&#39;&#34;)

    def export_visualisation(self, folder, use_cdn=True):
        &#34;&#34;&#34;
        Exports the visualisation prepared for this `Aurum` object as a standalone
        webpage to the given folder.

        If `use_cdn` is `True` (the default case), only a single HTML file will be
        generated, and additional JS/CSS sources will be loaded from a CDN instead.

        Otherwise, the additional JS/CSS sources will be exported directly into the
        target folder together with the main visualisation file -- Be sure to include
        the entire exported folder when moving it to a different location for display
        (e.g., on a PC with no internet access).

        Parameters
        ----------
        folder: str or pathlib.Path
            The folder to export the visualisation to.
        use_cdn: bool, optional
            If True, will save a single HTML file and attempt to load additional JS/CSS
            sources from a CDN instead.
        &#34;&#34;&#34;
        vis_data = self.get_vis_data()

        # Assuming the `vis_data` get is successful, we should have a valid record of
        # the `vis_type` as well.
        if self.vis_type == &#34;pyldavis&#34;:
            ignis.vis.pyldavis.export_visualisation(vis_data, folder, use_cdn)
        else:
            raise RuntimeError(f&#34;Unknown saved visualisation type: &#39;{self.vis_type}&#39;&#34;)

    # =================================================================================
    # Jupyter widgets
    def nb_explore_topics(
        self,
        top_words=30,
        top_labels=15,
        doc_sort_key=None,
        display_fn=None,
        max_display_length=50000,
        metadata_full_doc_link=&#34;filename&#34;,
    ):
        &#34;&#34;&#34;
        Convenience function that creates an interactive Jupyter notebook widget for
        exploring the topics and `ignis.corpus.Document` objects tracked by this model.

        By default, `ignis.corpus.Document` objects are displayed in decreasing order
        of probability for each specified topic, but a custom sorting function can be
        passed via `doc_sort_key` as well.

        Suggested topic labels will be shown if the model has a labeller initialised.

        Parameters
        ----------
        top_words: int, optional
            The top `n` most probable terms for each topic to show.
        top_labels: int, optional
            The top `n` most probable labels for each topic to show.

            Will have no effect if the model does not have a labeller initialised.
        doc_sort_key: fn, optional
            If specified, will sort `ignis.corpus.Document` objects for each topic
            using this key when displaying them.
        display_fn: fn, optional
            Custom display function that receives an individual
            `ignis.corpus.Document` as input, and should display the
            `ignis.corpus.Document` in human-readable form as a side effect.

            If unset, will assume that the human-readable representation of the
            `ignis.corpus.Document` is in HTML format and display it accordingly.
        max_display_length: int, optional
            Maximum length (in characters) to display from the
            `ignis.corpus.Document` object&#39;s human-readable representation.  If the
            `ignis.corpus.Document` object&#39;s human-readable representation is longer
            than this limit, a link will be generated to view the full human-readable
            representation in a new window.

            No effect if `display_fn` is set.
        metadata_full_doc_link: str, optional
            If `max_display_length` is exceeded, this key is used to get the path to
            the full human-readable representation from the `Document` object&#39;s
            metadata dictionary.

            No effect if `display_fn` is set.
        &#34;&#34;&#34;
        import ipywidgets
        from IPython.core.display import display, HTML
        import ignis.util.jupyter_styles

        # Set up widget styling
        # noinspection PyTypeChecker
        display(HTML(ignis.util.jupyter_styles.jupyter_output_style))

        # Per topic info
        def show_topic(topic_id=1):
            # Top tokens
            words = &#34;, &#34;.join(
                word
                for word, probability in self.get_topic_words(topic_id, top_n=top_words)
            )
            print(f&#34;Top tokens:\n{words}&#34;)

            # Labels
            if self.labeller is not None:
                labels = &#34;, &#34;.join(
                    label
                    for label, score in self.get_topic_labels(
                        topic_id, top_n=top_labels
                    )
                )
                print(f&#34;\nSuggested labels:\n{labels}&#34;)

            top_n_header = ipywidgets.Output()
            # noinspection PyTypeChecker
            display(top_n_header)

            # Topic documents -- `within_top_n`
            def show_topic_doc(within_top_n=1):
                with top_n_header:
                    top_n_header.clear_output(wait=True)
                    # noinspection PyTypeChecker
                    display(
                        HTML(
                            f&#34;&lt;h4&gt;Documents with Topic {topic_id} in the top &#34;
                            f&#34;{within_top_n} topic(s)&lt;/h4&gt;&#34;
                        )
                    )

                # Grab the documents that match the params passed, sorted by topic
                # probability in descending order
                topic_probs = self.get_topic_documents(topic_id, within_top_n)
                topic_probs = sorted(topic_probs, key=lambda x: x[1], reverse=True)

                topic_docs = [doc_id for doc_id, prob in topic_probs]

                if len(topic_docs) == 0:
                    print(
                        &#34;No documents matching the given topic parameters. &#34;
                        &#34;Try increasing `n`, or reducing the number of total topics &#34;
                        &#34;and retraining the model.&#34;
                    )
                    return

                topic_docs = [self.get_document(doc_id) for doc_id in topic_docs]

                if doc_sort_key is not None:
                    topic_docs = sorted(topic_docs, key=doc_sort_key)

                # Show actual document
                def show_doc(index=1):
                    # Start `index` from 1 for user-friendliness
                    print(f&#34;[Total documents: {len(topic_docs)}]\n&#34;)
                    doc = topic_docs[index - 1]

                    if display_fn is None:
                        # Default HTML display
                        print(f&#34;ID: {doc.id}&#34;)
                        if &#34;filename&#34; in doc.metadata:
                            print(f&#34;Filename: {doc.metadata[&#39;filename&#39;]}&#34;)
                        if &#34;txt_filename&#34; in doc.metadata:
                            print(f&#34;Processed: {doc.metadata[&#39;txt_filename&#39;]}&#34;)

                        if &#34;sender&#34; in doc.metadata:
                            print(f&#34;Sender: {doc.metadata[&#39;sender&#39;]}&#34;)
                        if &#34;recipients&#34; in doc.metadata:
                            recipients = doc.metadata[&#34;recipients&#34;]

                            # Truncate long recipient lists for display
                            # (TODO: Make this optional?)
                            if len(recipients) &gt; 5:
                                recipients = recipients[:5] + [&#34;...&#34;]

                            print(f&#34;Recipients:\n{json.dumps(recipients, indent=2)}&#34;)

                        # Jupyter notebooks will interpret anything between $ signs
                        # as LaTeX formulae when rendering HTML output, so we need to
                        # replace them with escaped $ signs (only in Jupyter
                        # environments)
                        display_str = doc.display_str.replace(&#34;$&#34;, r&#34;\$&#34;)

                        # Length check
                        if len(display_str) &gt; max_display_length:
                            display_str = (
                                f&#34;&lt;p&gt;&#34;
                                f&#34;&lt;b&gt;Document too long to display in full - &#34;
                                f&#34;Showing first {max_display_length} &#34;
                                f&#34;characters.&lt;/b&gt;&#34;
                                f&#34;&lt;/p&gt;&#34;
                                f&#34;&lt;p&gt;&#34;
                                f&#34;&lt;a href=&#34;
                                f&#34;&#39;{doc.metadata[metadata_full_doc_link]}&#39; &#34;
                                f&#34;target=&#39;_blank&#39;&gt;&#34;
                                f&#34;Click here&#34;
                                f&#34;&lt;/a&gt; to open the full document in a new &#34;
                                f&#34;tab/window.&#34;
                                f&#34;&lt;/p&gt;&#34;
                                f&#34;&lt;hr/&gt;&#34; + display_str[:max_display_length]
                            )

                        # noinspection PyTypeChecker
                        display(HTML(display_str))
                    else:
                        # User-provided display function
                        display_fn(doc)
                    print()
                    print(
                        &#34;Top 10 document topics (in descending order of probability):&#34;
                    )
                    top_topics = self.get_document_topics(doc.id, 10)
                    # Use a more readable format
                    for topic, prob in top_topics:
                        print(f&#34;Topic {topic}: {prob*100:.2f}%&#34;)

                # Control and output widgets for the document viewer
                slider = ipywidgets.IntSlider(
                    description=&#34;Document&#34;,
                    min=1,
                    max=len(topic_docs),
                    continuous_update=False,
                    layout=ignis.util.jupyter_styles.slider_layout,
                    style=ignis.util.jupyter_styles.slider_style,
                )
                text = ipywidgets.BoundedIntText(
                    min=1,
                    max=len(topic_docs),
                    layout=ignis.util.jupyter_styles.slider_text_layout,
                )
                ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
                ui = ipywidgets.HBox([slider, text])
                out = ipywidgets.interactive_output(show_doc, {&#34;index&#34;: slider})
                # noinspection PyTypeChecker
                display(ui, out)

            # Control and output widgets for the document top-n-topics viewer
            slider = ipywidgets.IntSlider(
                description=&#34;No. of topics to consider per doc&#34;,
                min=1,
                max=self.get_num_topics(),
                continuous_update=False,
                layout=ignis.util.jupyter_styles.slider_layout,
                style=ignis.util.jupyter_styles.slider_style,
            )
            text = ipywidgets.BoundedIntText(
                min=1,
                max=self.get_num_topics(),
                layout=ignis.util.jupyter_styles.slider_text_layout,
            )
            ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
            ui = ipywidgets.HBox([slider, text])
            out = ipywidgets.interactive_output(
                show_topic_doc, {&#34;within_top_n&#34;: slider}
            )
            # noinspection PyTypeChecker
            display(ui, out)

        # Control and output widgets for the topic viewer
        slider = ipywidgets.IntSlider(
            description=&#34;Topic&#34;,
            min=1,
            max=self.get_num_topics(),
            continuous_update=False,
            layout=ignis.util.jupyter_styles.slider_layout,
            style=ignis.util.jupyter_styles.slider_style,
        )
        text = ipywidgets.BoundedIntText(
            min=1,
            max=self.get_num_topics(),
            layout=ignis.util.jupyter_styles.slider_text_layout,
        )
        ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
        ui = ipywidgets.HBox([slider, text])
        out = ipywidgets.interactive_output(show_topic, {&#34;topic_id&#34;: slider})
        # noinspection PyTypeChecker
        display(ui, out)

    # =================================================================================
    # Slicing and Iteration
    # Convenience functions that help with the exploring the Model-Corpus interface
    def slice_by_topics(self, topic_ids, within_top_n=1, ignore_topics=None):
        &#34;&#34;&#34;
        General form of `Aurum.slice_by_topic()`.

        Parameters
        ----------
        topic_ids: iterable of int
            The IDs of the topics to consider.
        within_top_n: int, optional
            How many of each `ignis.corpus.Document` object&#39;s top topics to consider.
        ignore_topics: iterable of int, optional
            Don&#39;t count any of these topics if they are within the top `n` for a
            `ignis.corpus.Document`.

            E.g., for a `ignis.corpus.Document` with top topics `[5, 1, 3, ...]`,
            setting `ignore_topics` to `[5]` will consider the document&#39;s top topics
            to be `[1, 3, ...]` instead.

        Returns
        -------
        ignis.corpus.CorpusSlice
        &#34;&#34;&#34;
        if ignore_topics is None:
            ignore_topics = []

        all_doc_ids = []
        for doc_id in self.document_ids:
            # This is a list of (&lt;topic&gt;, &lt;prob&gt;)
            doc_topics = self.get_document_topics(
                doc_id, within_top_n + len(ignore_topics)
            )
            doc_topics = sorted(doc_topics, key=lambda x: x[1], reverse=True)
            checked_topics = 0
            for topic, prob in doc_topics:
                if topic not in ignore_topics:
                    # We&#39;ve seen one more topic for this document
                    checked_topics += 1

                if checked_topics &gt; within_top_n:
                    # Exceeded the topic check limit for this document
                    break

                if topic in topic_ids:
                    # Add it and go to the next document, we&#39;re done here
                    all_doc_ids.append(doc_id)
                    break

        return self.slice_by_ids(all_doc_ids)

    def slice_by_topic(self, topic_id, within_top_n=1, ignore_topics=None):
        &#34;&#34;&#34;
        Convenience function to create a new `ignis.corpus.CorpusSlice` containing the
        `ignis.corpus.Document` objects that have the given topic as one of their top
        `n` topics under the current model.

        **NOTE**: `topic_id` is 1-indexed, not 0-indexed (i.e., it is in `range(1,
        len(topics) + 1)`).

        Parameters
        ----------
        topic_id: int
            The ID of the topic to consider.
        within_top_n: int, optional
            How many of each `ignis.corpus.Document` object&#39;s top topics to consider.
        ignore_topics: iterable of int, optional
            Don&#39;t count any of these topics if they are within the top `n` for a
            `ignis.corpus.Document`.

            E.g., for a `ignis.corpus.Document` with top topics `[5, 1, 3, ...]`,
            setting `ignore_topics` to `[5]` will consider the document&#39;s top topics
            to be `[1, 3, ...]` instead.

        Returns
        -------
        ignis.corpus.CorpusSlice
        &#34;&#34;&#34;
        return self.slice_by_topics([topic_id], within_top_n, ignore_topics)

    def retrain_model(
        self,
        corpus_slice=None,
        model_type=None,
        model_options=None,
        labeller_type=None,
        labeller_options=None,
        vis_type=None,
        vis_options=None,
    ):
        &#34;&#34;&#34;
        (Re-)trains a topic model over some `ignis.corpus.CorpusSlice`.

        If `model_type`, `labeller_type`, and/or `vis_type` are `None`, the saved
        options from this current `Aurum` object are carried over and used.

        If new `model_options`, `labeller_options`, and/or `vis_options` dictionaries
        are passed, they are _merged_ with the ones from this current `Aurum` object
        instead of replacing them outright.

        See `ignis.probat.train_model()` for more details on the various parameters.

        Parameters
        ----------
        corpus_slice: ignis.corpus.Corpus or ignis.corpus.CorpusSlice, optional
            The `ignis.corpus.CorpusSlice` to (re-)train the model for.
        model_type: str, optional
            The type of topic model to train.
        model_options: dict, optional
            If set, will be merged with this `Aurum` object&#39;s saved options.
        labeller_type: str, optional
            The type of automated labeller to train.
        labeller_options: dict, optional
            If set, will be merged with this `Aurum` object&#39;s saved options.
        vis_type: str, optional
            The type of visualisation to prepare.
        vis_options: dict, optional
            If set, will be merged with this `Aurum` object&#39;s saved options.

        Returns
        -------
        ignis.aurum.Aurum
            The results object for the newly-trained model, which can be used for
            further exploration and iteration.
        &#34;&#34;&#34;
        if corpus_slice is not None and len(corpus_slice) == 0:
            raise RuntimeError(&#34;Cannot retrain model on an empty CorpusSlice.&#34;)

        new_kwargs = {
            &#34;corpus_slice&#34;: corpus_slice or self.corpus_slice,
            &#34;model_type&#34;: model_type or self.model_type,
            &#34;vis_type&#34;: vis_type or self.vis_type,
        }

        # We can only look up current labeller settings if this object has a labeller
        # initialised in the first place
        if self.labeller is not None:
            if labeller_type is None:
                new_kwargs[&#34;labeller_type&#34;] = self.labeller.labeller_type
            if labeller_options is None:
                new_kwargs[&#34;labeller_options&#34;] = self.labeller.options

        # Merge option dictionaries, where available
        if model_options is not None:
            new_kwargs[&#34;model_options&#34;] = dict(self.model_options, **model_options)
        else:
            new_kwargs[&#34;model_options&#34;] = self.model_options

        if labeller_options is not None:
            if self.labeller is not None:
                new_kwargs[&#34;labeller_options&#34;] = dict(
                    self.labeller.options, **labeller_options
                )
            else:
                new_kwargs[&#34;labeller_options&#34;] = labeller_options

        if vis_options is not None:
            if self.vis_options is not None:
                new_kwargs[&#34;vis_options&#34;] = dict(self.vis_options, **vis_options)
            else:
                new_kwargs[&#34;vis_options&#34;] = vis_options
        else:
            new_kwargs[&#34;vis_options&#34;] = self.vis_options

        return ignis.probat.train_model(**new_kwargs)

    def resuggest_num_topics(
        self, corpus_slice=None, model_options=None, *args, **kwargs
    ):
        &#34;&#34;&#34;
        (Re-)suggests a possible number of topics for some
        `ignis.corpus.CorpusSlice`, using this `Aurum` object&#39;s saved options as
        defaults.

        If a new model options dict is passed, it will be _merged_ with the one from
        this current `Aurum` object instead of replacing it outright.

        All other parameters, including coherence calculation options, are passed
        through directly to `ignis.probat.suggest_num_topics()`.

        Parameters
        ----------
        corpus_slice: ignis.corpus.Corpus or ignis.corpus.CorpusSlice, optional
            The new slice to suggest a number of topics for.  If `None`, will use
            this `Aurum` object&#39;s current `ignis.corpus.CorpusSlice`.
        model_options: dict, optional
            Any options set here will be merged with the current model options.
        *args, **kwargs
            Passed on to `ignis.probat.suggest_num_topics()`.

        Returns
        -------
        int
            Suggested topic count.
        &#34;&#34;&#34;
        if corpus_slice is not None and len(corpus_slice) == 0:
            raise RuntimeError(&#34;Cannot retrain model on an empty CorpusSlice.&#34;)

        # The only options that are inherited directly from this `Aurum` instance are
        # `corpus_slice` and `model_options` (where appropriate)
        new_kwargs = {&#34;corpus_slice&#34;: corpus_slice or self.corpus_slice}

        # Merge option dictionaries, where available
        if model_options is not None:
            new_kwargs[&#34;model_options&#34;] = dict(self.model_options, **model_options)
        else:
            new_kwargs[&#34;model_options&#34;] = self.model_options

        # All other arguments can be passed straight to
        # `ignis.probat.suggest_num_topics()`, if set
        new_kwargs = dict(kwargs, **new_kwargs)

        return ignis.probat.suggest_num_topics(*args, **new_kwargs)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="ignis.aurum.Aurum.document_ids"><code class="name">var <span class="ident">document_ids</span></code></dt>
<dd>
<div class="desc"><p>Get the IDs of all the <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> objects that are covered by this
<code><a title="ignis" href="index.html">ignis</a></code> model.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>iterable</code> of <code>uuid.UUID</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def document_ids(self):
    &#34;&#34;&#34;
    Get the IDs of all the `ignis.corpus.Document` objects that are covered by this
    `ignis` model.

    Returns
    -------
    iterable of uuid.UUID
    &#34;&#34;&#34;
    return list(self.corpus_slice.document_ids)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ignis.aurum.Aurum.export_visualisation"><code class="name flex">
<span>def <span class="ident">export_visualisation</span></span>(<span>self, folder, use_cdn=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the visualisation prepared for this <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object as a standalone
webpage to the given folder.</p>
<p>If <code>use_cdn</code> is <code>True</code> (the default case), only a single HTML file will be
generated, and additional JS/CSS sources will be loaded from a CDN instead.</p>
<p>Otherwise, the additional JS/CSS sources will be exported directly into the
target folder together with the main visualisation file &ndash; Be sure to include
the entire exported folder when moving it to a different location for display
(e.g., on a PC with no internet access).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path</code></dt>
<dd>The folder to export the visualisation to.</dd>
<dt><strong><code>use_cdn</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, will save a single HTML file and attempt to load additional JS/CSS
sources from a CDN instead.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_visualisation(self, folder, use_cdn=True):
    &#34;&#34;&#34;
    Exports the visualisation prepared for this `Aurum` object as a standalone
    webpage to the given folder.

    If `use_cdn` is `True` (the default case), only a single HTML file will be
    generated, and additional JS/CSS sources will be loaded from a CDN instead.

    Otherwise, the additional JS/CSS sources will be exported directly into the
    target folder together with the main visualisation file -- Be sure to include
    the entire exported folder when moving it to a different location for display
    (e.g., on a PC with no internet access).

    Parameters
    ----------
    folder: str or pathlib.Path
        The folder to export the visualisation to.
    use_cdn: bool, optional
        If True, will save a single HTML file and attempt to load additional JS/CSS
        sources from a CDN instead.
    &#34;&#34;&#34;
    vis_data = self.get_vis_data()

    # Assuming the `vis_data` get is successful, we should have a valid record of
    # the `vis_type` as well.
    if self.vis_type == &#34;pyldavis&#34;:
        ignis.vis.pyldavis.export_visualisation(vis_data, folder, use_cdn)
    else:
        raise RuntimeError(f&#34;Unknown saved visualisation type: &#39;{self.vis_type}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_coherence"><code class="name flex">
<span>def <span class="ident">get_coherence</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="ignis.models.base.BaseModel.get_coherence" href="models/base.html#ignis.models.base.BaseModel.get_coherence">BaseModel.get_coherence()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coherence(self, *args, **kwargs):
    &#34;&#34;&#34;
    See `ignis.models.base.BaseModel.get_coherence()`.
    &#34;&#34;&#34;
    return self.ignis_model.get_coherence(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_document"><code class="name flex">
<span>def <span class="ident">get_document</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="ignis.corpus.CorpusSlice.get_document" href="corpus.html#ignis.corpus.Corpus.get_document">Corpus.get_document()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_document(self, *args, **kwargs):
    &#34;&#34;&#34;
    See `ignis.corpus.CorpusSlice.get_document()`.
    &#34;&#34;&#34;
    return self.corpus_slice.get_document(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_document_top_topic"><code class="name flex">
<span>def <span class="ident">get_document_top_topic</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="ignis.models.base.BaseModel.get_document_top_topic" href="models/base.html#ignis.models.base.BaseModel.get_document_top_topic">BaseModel.get_document_top_topic()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_document_top_topic(self, *args, **kwargs):
    &#34;&#34;&#34;
    See `ignis.models.base.BaseModel.get_document_top_topic()`.
    &#34;&#34;&#34;
    return self.ignis_model.get_document_top_topic(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_document_topics"><code class="name flex">
<span>def <span class="ident">get_document_topics</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="ignis.models.base.BaseModel.get_document_topics" href="models/base.html#ignis.models.base.BaseModel.get_document_topics">BaseModel.get_document_topics()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_document_topics(self, *args, **kwargs):
    &#34;&#34;&#34;
    See `ignis.models.base.BaseModel.get_document_topics()`.
    &#34;&#34;&#34;
    return self.ignis_model.get_document_topics(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_num_topics"><code class="name flex">
<span>def <span class="ident">get_num_topics</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="ignis.models.base.BaseModel.get_num_topics" href="models/base.html#ignis.models.base.BaseModel.get_num_topics">BaseModel.get_num_topics()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_topics(self):
    &#34;&#34;&#34;
    See `ignis.models.base.BaseModel.get_num_topics()`.
    &#34;&#34;&#34;
    return self.ignis_model.get_num_topics()</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_topic_documents"><code class="name flex">
<span>def <span class="ident">get_topic_documents</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="ignis.models.base.BaseModel.get_topic_documents" href="models/base.html#ignis.models.base.BaseModel.get_topic_documents">BaseModel.get_topic_documents()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_topic_documents(self, *args, **kwargs):
    &#34;&#34;&#34;
    See `ignis.models.base.BaseModel.get_topic_documents()`.
    &#34;&#34;&#34;
    return self.ignis_model.get_topic_documents(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_topic_labels"><code class="name flex">
<span>def <span class="ident">get_topic_labels</span></span>(<span>self, topic_id, top_n)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="ignis.labeller.tomotopy.TomotopyLabeller.get_topic_labels" href="labeller/tomotopy.html#ignis.labeller.tomotopy.TomotopyLabeller.get_topic_labels">TomotopyLabeller.get_topic_labels()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_topic_labels(self, topic_id, top_n):
    &#34;&#34;&#34;
    See `ignis.labeller.tomotopy.TomotopyLabeller.get_topic_labels()`.
    &#34;&#34;&#34;
    if self.labeller is None:
        raise RuntimeError(
            &#34;There is no labeller instantiated for this Aurum object. &#34;
            &#34;Use `.init_labeller()` to prepare one.&#34;
        )
    return self.labeller.get_topic_labels(topic_id, top_n)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_topic_words"><code class="name flex">
<span>def <span class="ident">get_topic_words</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="ignis.models.base.BaseModel.get_topic_words" href="models/base.html#ignis.models.base.BaseModel.get_topic_words">BaseModel.get_topic_words()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_topic_words(self, *args, **kwargs):
    &#34;&#34;&#34;
    See `ignis.models.base.BaseModel.get_topic_words()`.
    &#34;&#34;&#34;
    return self.ignis_model.get_topic_words(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_vis_data"><code class="name flex">
<span>def <span class="ident">get_vis_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the prepared visualisation data for this model, if any.</p>
<p>Different visualisation classes may have different ways of storing and
representing this data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vis_data(self):
    &#34;&#34;&#34;
    Returns the prepared visualisation data for this model, if any.

    Different visualisation classes may have different ways of storing and
    representing this data.
    &#34;&#34;&#34;
    if self.vis_data is None:
        raise RuntimeError(
            &#34;There is no visualisation data instantiated for this Aurum object. &#34;
            &#34;Use `.init_vis()` to prepare it.&#34;
        )
    return self.vis_data</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.get_visualisation_html"><code class="name flex">
<span>def <span class="ident">get_visualisation_html</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the prepared visualisation for this model as a raw HTML string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Passed through to the visualisation module.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The output of the <code>get_visualisation_html</code> method of the relevant <code><a title="ignis.vis" href="vis/index.html">ignis.vis</a></code>
class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_visualisation_html(self, **kwargs):
    &#34;&#34;&#34;
    Gets the prepared visualisation for this model as a raw HTML string.

    Parameters
    ----------
    **kwargs
        Passed through to the visualisation module.

    Returns
    -------
    The output of the `get_visualisation_html` method of the relevant `ignis.vis`
    class.
    &#34;&#34;&#34;
    vis_data = self.get_vis_data()

    if self.vis_type == &#34;pyldavis&#34;:
        return ignis.vis.pyldavis.get_visualisation_html(vis_data, **kwargs)
    else:
        raise RuntimeError(f&#34;Unknown saved visualisation type: &#39;{self.vis_type}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.init_labeller"><code class="name flex">
<span>def <span class="ident">init_labeller</span></span>(<span>self, labeller_type, **labeller_options)</span>
</code></dt>
<dd>
<div class="desc"><p>Trains an automated <code><a title="ignis.labeller" href="labeller/index.html">ignis.labeller</a></code> for this <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>labeller_type</code></strong> :&ensp;<code>{"tomotopy"}</code></dt>
<dd>String denoting the labeller type.</dd>
<dt><strong><code>**labeller_options</code></strong></dt>
<dd>Keyword arguments that are passed to the constructor for the given
labeller type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_labeller(self, labeller_type, **labeller_options):
    &#34;&#34;&#34;
    Trains an automated `ignis.labeller` for this `Aurum` object.

    Parameters
    ----------
    labeller_type: {&#34;tomotopy&#34;}
        String denoting the labeller type.
    **labeller_options
        Keyword arguments that are passed to the constructor for the given
        labeller type.
    &#34;&#34;&#34;
    if labeller_type == &#34;tomotopy&#34;:
        self.labeller = ignis.labeller.tomotopy.TomotopyLabeller(
            self.ignis_model.model, **labeller_options
        )
    else:
        raise ValueError(f&#34;Unknown labeller type: &#39;{labeller_type}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.init_vis"><code class="name flex">
<span>def <span class="ident">init_vis</span></span>(<span>self, vis_type, force=False, **vis_options)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares the visualisation data for this <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object in the specified
format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vis_type</code></strong> :&ensp;<code>{"pyldavis", "clear"}</code></dt>
<dd>String denoting the visualisation type.
Passing <code>"clear"</code> will remove
any existing visualisation data.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Forces recalculation of <code>self.vis_data</code>, if it already exists.</dd>
<dt><strong><code>**vis_options</code></strong></dt>
<dd>Keyword arguments that are passed to the constructor for the given
visualisation type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_vis(self, vis_type, force=False, **vis_options):
    &#34;&#34;&#34;
    Prepares the visualisation data for this `Aurum` object in the specified
    format.

    Parameters
    ----------
    vis_type: {&#34;pyldavis&#34;, &#34;clear&#34;}
        String denoting the visualisation type.  Passing `&#34;clear&#34;` will remove
        any existing visualisation data.
    force: bool, optional
        Forces recalculation of `self.vis_data`, if it already exists.
    **vis_options
        Keyword arguments that are passed to the constructor for the given
        visualisation type.
    &#34;&#34;&#34;
    if vis_type == &#34;clear&#34;:
        self.vis_type = None
        self.vis_options = None
        self.vis_data = None
    elif vis_type == &#34;pyldavis&#34;:
        if self.vis_data is not None and not force:
            raise RuntimeError(
                f&#34;Visualisation data already exists for this Aurum object &#34;
                f&#34;(type: &#39;{self.vis_type}&#39;). &#34;
                f&#34;Pass `force=True` to force recalculation.&#34;
            )

        self.vis_type = vis_type
        self.vis_options = vis_options
        self.vis_data = ignis.vis.pyldavis.prepare_data(
            self.ignis_model.model, **vis_options
        )
    else:
        raise ValueError(f&#34;Unknown visualisation type: &#39;{vis_type}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.nb_explore_topics"><code class="name flex">
<span>def <span class="ident">nb_explore_topics</span></span>(<span>self, top_words=30, top_labels=15, doc_sort_key=None, display_fn=None, max_display_length=50000, metadata_full_doc_link='filename')</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function that creates an interactive Jupyter notebook widget for
exploring the topics and <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> objects tracked by this model.</p>
<p>By default, <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> objects are displayed in decreasing order
of probability for each specified topic, but a custom sorting function can be
passed via <code>doc_sort_key</code> as well.</p>
<p>Suggested topic labels will be shown if the model has a labeller initialised.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>top_words</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The top <code>n</code> most probable terms for each topic to show.</dd>
<dt><strong><code>top_labels</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>
<p>The top <code>n</code> most probable labels for each topic to show.</p>
<p>Will have no effect if the model does not have a labeller initialised.</p>
</dd>
<dt><strong><code>doc_sort_key</code></strong> :&ensp;<code>fn</code>, optional</dt>
<dd>If specified, will sort <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> objects for each topic
using this key when displaying them.</dd>
<dt><strong><code>display_fn</code></strong> :&ensp;<code>fn</code>, optional</dt>
<dd>
<p>Custom display function that receives an individual
<code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> as input, and should display the
<code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> in human-readable form as a side effect.</p>
<p>If unset, will assume that the human-readable representation of the
<code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> is in HTML format and display it accordingly.</p>
</dd>
<dt><strong><code>max_display_length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>
<p>Maximum length (in characters) to display from the
<code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> object's human-readable representation.
If the
<code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> object's human-readable representation is longer
than this limit, a link will be generated to view the full human-readable
representation in a new window.</p>
<p>No effect if <code>display_fn</code> is set.</p>
</dd>
<dt><strong><code>metadata_full_doc_link</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>If <code>max_display_length</code> is exceeded, this key is used to get the path to
the full human-readable representation from the <code>Document</code> object's
metadata dictionary.</p>
<p>No effect if <code>display_fn</code> is set.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nb_explore_topics(
    self,
    top_words=30,
    top_labels=15,
    doc_sort_key=None,
    display_fn=None,
    max_display_length=50000,
    metadata_full_doc_link=&#34;filename&#34;,
):
    &#34;&#34;&#34;
    Convenience function that creates an interactive Jupyter notebook widget for
    exploring the topics and `ignis.corpus.Document` objects tracked by this model.

    By default, `ignis.corpus.Document` objects are displayed in decreasing order
    of probability for each specified topic, but a custom sorting function can be
    passed via `doc_sort_key` as well.

    Suggested topic labels will be shown if the model has a labeller initialised.

    Parameters
    ----------
    top_words: int, optional
        The top `n` most probable terms for each topic to show.
    top_labels: int, optional
        The top `n` most probable labels for each topic to show.

        Will have no effect if the model does not have a labeller initialised.
    doc_sort_key: fn, optional
        If specified, will sort `ignis.corpus.Document` objects for each topic
        using this key when displaying them.
    display_fn: fn, optional
        Custom display function that receives an individual
        `ignis.corpus.Document` as input, and should display the
        `ignis.corpus.Document` in human-readable form as a side effect.

        If unset, will assume that the human-readable representation of the
        `ignis.corpus.Document` is in HTML format and display it accordingly.
    max_display_length: int, optional
        Maximum length (in characters) to display from the
        `ignis.corpus.Document` object&#39;s human-readable representation.  If the
        `ignis.corpus.Document` object&#39;s human-readable representation is longer
        than this limit, a link will be generated to view the full human-readable
        representation in a new window.

        No effect if `display_fn` is set.
    metadata_full_doc_link: str, optional
        If `max_display_length` is exceeded, this key is used to get the path to
        the full human-readable representation from the `Document` object&#39;s
        metadata dictionary.

        No effect if `display_fn` is set.
    &#34;&#34;&#34;
    import ipywidgets
    from IPython.core.display import display, HTML
    import ignis.util.jupyter_styles

    # Set up widget styling
    # noinspection PyTypeChecker
    display(HTML(ignis.util.jupyter_styles.jupyter_output_style))

    # Per topic info
    def show_topic(topic_id=1):
        # Top tokens
        words = &#34;, &#34;.join(
            word
            for word, probability in self.get_topic_words(topic_id, top_n=top_words)
        )
        print(f&#34;Top tokens:\n{words}&#34;)

        # Labels
        if self.labeller is not None:
            labels = &#34;, &#34;.join(
                label
                for label, score in self.get_topic_labels(
                    topic_id, top_n=top_labels
                )
            )
            print(f&#34;\nSuggested labels:\n{labels}&#34;)

        top_n_header = ipywidgets.Output()
        # noinspection PyTypeChecker
        display(top_n_header)

        # Topic documents -- `within_top_n`
        def show_topic_doc(within_top_n=1):
            with top_n_header:
                top_n_header.clear_output(wait=True)
                # noinspection PyTypeChecker
                display(
                    HTML(
                        f&#34;&lt;h4&gt;Documents with Topic {topic_id} in the top &#34;
                        f&#34;{within_top_n} topic(s)&lt;/h4&gt;&#34;
                    )
                )

            # Grab the documents that match the params passed, sorted by topic
            # probability in descending order
            topic_probs = self.get_topic_documents(topic_id, within_top_n)
            topic_probs = sorted(topic_probs, key=lambda x: x[1], reverse=True)

            topic_docs = [doc_id for doc_id, prob in topic_probs]

            if len(topic_docs) == 0:
                print(
                    &#34;No documents matching the given topic parameters. &#34;
                    &#34;Try increasing `n`, or reducing the number of total topics &#34;
                    &#34;and retraining the model.&#34;
                )
                return

            topic_docs = [self.get_document(doc_id) for doc_id in topic_docs]

            if doc_sort_key is not None:
                topic_docs = sorted(topic_docs, key=doc_sort_key)

            # Show actual document
            def show_doc(index=1):
                # Start `index` from 1 for user-friendliness
                print(f&#34;[Total documents: {len(topic_docs)}]\n&#34;)
                doc = topic_docs[index - 1]

                if display_fn is None:
                    # Default HTML display
                    print(f&#34;ID: {doc.id}&#34;)
                    if &#34;filename&#34; in doc.metadata:
                        print(f&#34;Filename: {doc.metadata[&#39;filename&#39;]}&#34;)
                    if &#34;txt_filename&#34; in doc.metadata:
                        print(f&#34;Processed: {doc.metadata[&#39;txt_filename&#39;]}&#34;)

                    if &#34;sender&#34; in doc.metadata:
                        print(f&#34;Sender: {doc.metadata[&#39;sender&#39;]}&#34;)
                    if &#34;recipients&#34; in doc.metadata:
                        recipients = doc.metadata[&#34;recipients&#34;]

                        # Truncate long recipient lists for display
                        # (TODO: Make this optional?)
                        if len(recipients) &gt; 5:
                            recipients = recipients[:5] + [&#34;...&#34;]

                        print(f&#34;Recipients:\n{json.dumps(recipients, indent=2)}&#34;)

                    # Jupyter notebooks will interpret anything between $ signs
                    # as LaTeX formulae when rendering HTML output, so we need to
                    # replace them with escaped $ signs (only in Jupyter
                    # environments)
                    display_str = doc.display_str.replace(&#34;$&#34;, r&#34;\$&#34;)

                    # Length check
                    if len(display_str) &gt; max_display_length:
                        display_str = (
                            f&#34;&lt;p&gt;&#34;
                            f&#34;&lt;b&gt;Document too long to display in full - &#34;
                            f&#34;Showing first {max_display_length} &#34;
                            f&#34;characters.&lt;/b&gt;&#34;
                            f&#34;&lt;/p&gt;&#34;
                            f&#34;&lt;p&gt;&#34;
                            f&#34;&lt;a href=&#34;
                            f&#34;&#39;{doc.metadata[metadata_full_doc_link]}&#39; &#34;
                            f&#34;target=&#39;_blank&#39;&gt;&#34;
                            f&#34;Click here&#34;
                            f&#34;&lt;/a&gt; to open the full document in a new &#34;
                            f&#34;tab/window.&#34;
                            f&#34;&lt;/p&gt;&#34;
                            f&#34;&lt;hr/&gt;&#34; + display_str[:max_display_length]
                        )

                    # noinspection PyTypeChecker
                    display(HTML(display_str))
                else:
                    # User-provided display function
                    display_fn(doc)
                print()
                print(
                    &#34;Top 10 document topics (in descending order of probability):&#34;
                )
                top_topics = self.get_document_topics(doc.id, 10)
                # Use a more readable format
                for topic, prob in top_topics:
                    print(f&#34;Topic {topic}: {prob*100:.2f}%&#34;)

            # Control and output widgets for the document viewer
            slider = ipywidgets.IntSlider(
                description=&#34;Document&#34;,
                min=1,
                max=len(topic_docs),
                continuous_update=False,
                layout=ignis.util.jupyter_styles.slider_layout,
                style=ignis.util.jupyter_styles.slider_style,
            )
            text = ipywidgets.BoundedIntText(
                min=1,
                max=len(topic_docs),
                layout=ignis.util.jupyter_styles.slider_text_layout,
            )
            ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
            ui = ipywidgets.HBox([slider, text])
            out = ipywidgets.interactive_output(show_doc, {&#34;index&#34;: slider})
            # noinspection PyTypeChecker
            display(ui, out)

        # Control and output widgets for the document top-n-topics viewer
        slider = ipywidgets.IntSlider(
            description=&#34;No. of topics to consider per doc&#34;,
            min=1,
            max=self.get_num_topics(),
            continuous_update=False,
            layout=ignis.util.jupyter_styles.slider_layout,
            style=ignis.util.jupyter_styles.slider_style,
        )
        text = ipywidgets.BoundedIntText(
            min=1,
            max=self.get_num_topics(),
            layout=ignis.util.jupyter_styles.slider_text_layout,
        )
        ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
        ui = ipywidgets.HBox([slider, text])
        out = ipywidgets.interactive_output(
            show_topic_doc, {&#34;within_top_n&#34;: slider}
        )
        # noinspection PyTypeChecker
        display(ui, out)

    # Control and output widgets for the topic viewer
    slider = ipywidgets.IntSlider(
        description=&#34;Topic&#34;,
        min=1,
        max=self.get_num_topics(),
        continuous_update=False,
        layout=ignis.util.jupyter_styles.slider_layout,
        style=ignis.util.jupyter_styles.slider_style,
    )
    text = ipywidgets.BoundedIntText(
        min=1,
        max=self.get_num_topics(),
        layout=ignis.util.jupyter_styles.slider_text_layout,
    )
    ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
    ui = ipywidgets.HBox([slider, text])
    out = ipywidgets.interactive_output(show_topic, {&#34;topic_id&#34;: slider})
    # noinspection PyTypeChecker
    display(ui, out)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.resuggest_num_topics"><code class="name flex">
<span>def <span class="ident">resuggest_num_topics</span></span>(<span>self, corpus_slice=None, model_options=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>(Re-)suggests a possible number of topics for some
<code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>, using this <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object's saved options as
defaults.</p>
<p>If a new model options dict is passed, it will be <em>merged</em> with the one from
this current <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object instead of replacing it outright.</p>
<p>All other parameters, including coherence calculation options, are passed
through directly to <code><a title="ignis.probat.suggest_num_topics" href="probat.html#ignis.probat.suggest_num_topics">suggest_num_topics()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>corpus_slice</code></strong> :&ensp;<code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code> or <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>, optional</dt>
<dd>The new slice to suggest a number of topics for.
If <code>None</code>, will use
this <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</dd>
<dt><strong><code>model_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Any options set here will be merged with the current model options.</dd>
<dt><strong><code>*args</code></strong>, <strong><code>**kwargs</code></strong></dt>
<dd>Passed on to <code><a title="ignis.probat.suggest_num_topics" href="probat.html#ignis.probat.suggest_num_topics">suggest_num_topics()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Suggested topic count.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resuggest_num_topics(
    self, corpus_slice=None, model_options=None, *args, **kwargs
):
    &#34;&#34;&#34;
    (Re-)suggests a possible number of topics for some
    `ignis.corpus.CorpusSlice`, using this `Aurum` object&#39;s saved options as
    defaults.

    If a new model options dict is passed, it will be _merged_ with the one from
    this current `Aurum` object instead of replacing it outright.

    All other parameters, including coherence calculation options, are passed
    through directly to `ignis.probat.suggest_num_topics()`.

    Parameters
    ----------
    corpus_slice: ignis.corpus.Corpus or ignis.corpus.CorpusSlice, optional
        The new slice to suggest a number of topics for.  If `None`, will use
        this `Aurum` object&#39;s current `ignis.corpus.CorpusSlice`.
    model_options: dict, optional
        Any options set here will be merged with the current model options.
    *args, **kwargs
        Passed on to `ignis.probat.suggest_num_topics()`.

    Returns
    -------
    int
        Suggested topic count.
    &#34;&#34;&#34;
    if corpus_slice is not None and len(corpus_slice) == 0:
        raise RuntimeError(&#34;Cannot retrain model on an empty CorpusSlice.&#34;)

    # The only options that are inherited directly from this `Aurum` instance are
    # `corpus_slice` and `model_options` (where appropriate)
    new_kwargs = {&#34;corpus_slice&#34;: corpus_slice or self.corpus_slice}

    # Merge option dictionaries, where available
    if model_options is not None:
        new_kwargs[&#34;model_options&#34;] = dict(self.model_options, **model_options)
    else:
        new_kwargs[&#34;model_options&#34;] = self.model_options

    # All other arguments can be passed straight to
    # `ignis.probat.suggest_num_topics()`, if set
    new_kwargs = dict(kwargs, **new_kwargs)

    return ignis.probat.suggest_num_topics(*args, **new_kwargs)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.retrain_model"><code class="name flex">
<span>def <span class="ident">retrain_model</span></span>(<span>self, corpus_slice=None, model_type=None, model_options=None, labeller_type=None, labeller_options=None, vis_type=None, vis_options=None)</span>
</code></dt>
<dd>
<div class="desc"><p>(Re-)trains a topic model over some <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>If <code>model_type</code>, <code>labeller_type</code>, and/or <code>vis_type</code> are <code>None</code>, the saved
options from this current <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object are carried over and used.</p>
<p>If new <code>model_options</code>, <code>labeller_options</code>, and/or <code>vis_options</code> dictionaries
are passed, they are <em>merged</em> with the ones from this current <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object
instead of replacing them outright.</p>
<p>See <code><a title="ignis.probat.train_model" href="probat.html#ignis.probat.train_model">train_model()</a></code> for more details on the various parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>corpus_slice</code></strong> :&ensp;<code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code> or <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>, optional</dt>
<dd>The <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code> to (re-)train the model for.</dd>
<dt><strong><code>model_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The type of topic model to train.</dd>
<dt><strong><code>model_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>If set, will be merged with this <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object's saved options.</dd>
<dt><strong><code>labeller_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The type of automated labeller to train.</dd>
<dt><strong><code>labeller_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>If set, will be merged with this <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object's saved options.</dd>
<dt><strong><code>vis_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The type of visualisation to prepare.</dd>
<dt><strong><code>vis_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>If set, will be merged with this <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object's saved options.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code></dt>
<dd>The results object for the newly-trained model, which can be used for
further exploration and iteration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrain_model(
    self,
    corpus_slice=None,
    model_type=None,
    model_options=None,
    labeller_type=None,
    labeller_options=None,
    vis_type=None,
    vis_options=None,
):
    &#34;&#34;&#34;
    (Re-)trains a topic model over some `ignis.corpus.CorpusSlice`.

    If `model_type`, `labeller_type`, and/or `vis_type` are `None`, the saved
    options from this current `Aurum` object are carried over and used.

    If new `model_options`, `labeller_options`, and/or `vis_options` dictionaries
    are passed, they are _merged_ with the ones from this current `Aurum` object
    instead of replacing them outright.

    See `ignis.probat.train_model()` for more details on the various parameters.

    Parameters
    ----------
    corpus_slice: ignis.corpus.Corpus or ignis.corpus.CorpusSlice, optional
        The `ignis.corpus.CorpusSlice` to (re-)train the model for.
    model_type: str, optional
        The type of topic model to train.
    model_options: dict, optional
        If set, will be merged with this `Aurum` object&#39;s saved options.
    labeller_type: str, optional
        The type of automated labeller to train.
    labeller_options: dict, optional
        If set, will be merged with this `Aurum` object&#39;s saved options.
    vis_type: str, optional
        The type of visualisation to prepare.
    vis_options: dict, optional
        If set, will be merged with this `Aurum` object&#39;s saved options.

    Returns
    -------
    ignis.aurum.Aurum
        The results object for the newly-trained model, which can be used for
        further exploration and iteration.
    &#34;&#34;&#34;
    if corpus_slice is not None and len(corpus_slice) == 0:
        raise RuntimeError(&#34;Cannot retrain model on an empty CorpusSlice.&#34;)

    new_kwargs = {
        &#34;corpus_slice&#34;: corpus_slice or self.corpus_slice,
        &#34;model_type&#34;: model_type or self.model_type,
        &#34;vis_type&#34;: vis_type or self.vis_type,
    }

    # We can only look up current labeller settings if this object has a labeller
    # initialised in the first place
    if self.labeller is not None:
        if labeller_type is None:
            new_kwargs[&#34;labeller_type&#34;] = self.labeller.labeller_type
        if labeller_options is None:
            new_kwargs[&#34;labeller_options&#34;] = self.labeller.options

    # Merge option dictionaries, where available
    if model_options is not None:
        new_kwargs[&#34;model_options&#34;] = dict(self.model_options, **model_options)
    else:
        new_kwargs[&#34;model_options&#34;] = self.model_options

    if labeller_options is not None:
        if self.labeller is not None:
            new_kwargs[&#34;labeller_options&#34;] = dict(
                self.labeller.options, **labeller_options
            )
        else:
            new_kwargs[&#34;labeller_options&#34;] = labeller_options

    if vis_options is not None:
        if self.vis_options is not None:
            new_kwargs[&#34;vis_options&#34;] = dict(self.vis_options, **vis_options)
        else:
            new_kwargs[&#34;vis_options&#34;] = vis_options
    else:
        new_kwargs[&#34;vis_options&#34;] = self.vis_options

    return ignis.probat.train_model(**new_kwargs)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the <code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code> object, including its associated <code><a title="ignis.models" href="models/index.html">ignis.models</a></code> model,
to the given file.
Essentially uses a bz2-compressed Pickle format.</p>
<p>Also attempts to save any cached visualisation data, but will omit any
initialised automated labeller (since labellers are probably not pickle-able).</p>
<p>We recommend using <em>.aurum</em> as the canonical file extension, but this is not
strictly enforced by the library.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path</code></dt>
<dd>File to save the model to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename):
    &#34;&#34;&#34;
    Saves the `Aurum` object, including its associated `ignis.models` model,
    to the given file.
    Essentially uses a bz2-compressed Pickle format.

    Also attempts to save any cached visualisation data, but will omit any
    initialised automated labeller (since labellers are probably not pickle-able).

    We recommend using _.aurum_ as the canonical file extension, but this is not
    strictly enforced by the library.

    Parameters
    ----------
    filename: str or pathlib.Path
        File to save the model to.
    &#34;&#34;&#34;
    filename = pathlib.Path(filename)

    # Copy the Ignis model, separate the external library&#39;s model out, pickle
    # everything together
    # (The model objects created by external libraries might not be pickle-able)
    external_model = self.ignis_model.model
    self.ignis_model.model = None
    save_model = copy.deepcopy(self.ignis_model)

    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_model_file = pathlib.Path(tmpdir) / &#34;save_model.bin&#34;
        # We assume that the external library&#39;s model object provides a `.save()`
        # method that takes the filename as a string
        tmp_model_file = str(tmp_model_file)
        external_model.save(tmp_model_file)
        with open(tmp_model_file, &#34;rb&#34;) as fp:
            external_model_bytes = fp.read()

    save_object = {
        &#34;save_model&#34;: save_model,
        &#34;model_type&#34;: save_model.model_type,
        &#34;external_model_bytes&#34;: external_model_bytes,
        # We should also be able to save any cached visualisation data, but the
        # labeller is probably not pickle-able.
        &#34;vis_type&#34;: self.vis_type,
        &#34;vis_options&#34;: self.vis_options,
        &#34;vis_data&#34;: self.vis_data,
    }

    with bz2.open(filename, &#34;wb&#34;) as fp:
        pickle.dump(save_object, fp)

    self.ignis_model.model = external_model</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.show_visualisation"><code class="name flex">
<span>def <span class="ident">show_visualisation</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the prepared visualisation for this model.</p>
<p>Presumes that the <code><a title="ignis.vis" href="vis/index.html">ignis.vis</a></code> class returns a situation-appropriate format
(e.g., for display in a Jupyter notebook)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Passed through to the visualisation module.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The output of the <code>show_visualisation</code> method of the relevant <code><a title="ignis.vis" href="vis/index.html">ignis.vis</a></code> class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_visualisation(self, **kwargs):
    &#34;&#34;&#34;
    Displays the prepared visualisation for this model.

    Presumes that the `ignis.vis` class returns a situation-appropriate format
    (e.g., for display in a Jupyter notebook)

    Parameters
    ----------
    **kwargs
        Passed through to the visualisation module.

    Returns
    -------
    The output of the `show_visualisation` method of the relevant `ignis.vis` class.
    &#34;&#34;&#34;
    vis_data = self.get_vis_data()

    if self.vis_type == &#34;pyldavis&#34;:
        return ignis.vis.pyldavis.show_visualisation(vis_data, **kwargs)
    else:
        raise RuntimeError(f&#34;Unknown saved visualisation type: &#39;{self.vis_type}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_by_ids"><code class="name flex">
<span>def <span class="ident">slice_by_ids</span></span>(<span>self, doc_ids, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset by the given <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> IDs.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_by_ids" href="corpus.html#ignis.corpus.Corpus.slice_by_ids">Corpus.slice_by_ids()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_ids(self, doc_ids, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset by the given `ignis.corpus.Document` IDs.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_by_ids()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_by_ids(doc_ids)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_by_text_string"><code class="name flex">
<span>def <span class="ident">slice_by_text_string</span></span>(<span>self, text_string, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset by the given text string.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_by_text_string" href="corpus.html#ignis.corpus.Corpus.slice_by_text_string">Corpus.slice_by_text_string()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_text_string(self, text_string, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset by the given text string.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_by_text_string()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_by_text_string(text_string)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_by_text_strings"><code class="name flex">
<span>def <span class="ident">slice_by_text_strings</span></span>(<span>self, text_strings, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset by the given text strings.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_by_text_strings" href="corpus.html#ignis.corpus.Corpus.slice_by_text_strings">Corpus.slice_by_text_strings()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_text_strings(self, text_strings, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset by the given text strings.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_by_text_strings()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_by_text_strings(text_strings)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_by_token"><code class="name flex">
<span>def <span class="ident">slice_by_token</span></span>(<span>self, token, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset by the given token.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_by_token" href="corpus.html#ignis.corpus.Corpus.slice_by_token">Corpus.slice_by_token()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_token(self, token, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset by the given token.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_by_token()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_by_token(token)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_by_tokens"><code class="name flex">
<span>def <span class="ident">slice_by_tokens</span></span>(<span>self, tokens, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset by tokens.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_by_tokens" href="corpus.html#ignis.corpus.Corpus.slice_by_tokens">Corpus.slice_by_tokens()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_tokens(self, tokens, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset by tokens.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_by_tokens()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_by_tokens(tokens)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_by_topic"><code class="name flex">
<span>def <span class="ident">slice_by_topic</span></span>(<span>self, topic_id, within_top_n=1, ignore_topics=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to create a new <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code> containing the
<code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> objects that have the given topic as one of their top
<code>n</code> topics under the current model.</p>
<p><strong>NOTE</strong>: <code>topic_id</code> is 1-indexed, not 0-indexed (i.e., it is in <code>range(1,
len(topics) + 1)</code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>topic_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the topic to consider.</dd>
<dt><strong><code>within_top_n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How many of each <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> object's top topics to consider.</dd>
<dt><strong><code>ignore_topics</code></strong> :&ensp;<code>iterable</code> of <code>int</code>, optional</dt>
<dd>
<p>Don't count any of these topics if they are within the top <code>n</code> for a
<code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code>.</p>
<p>E.g., for a <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> with top topics <code>[5, 1, 3, &hellip;]</code>,
setting <code>ignore_topics</code> to <code>[5]</code> will consider the document's top topics
to be <code>[1, 3, &hellip;]</code> instead.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_topic(self, topic_id, within_top_n=1, ignore_topics=None):
    &#34;&#34;&#34;
    Convenience function to create a new `ignis.corpus.CorpusSlice` containing the
    `ignis.corpus.Document` objects that have the given topic as one of their top
    `n` topics under the current model.

    **NOTE**: `topic_id` is 1-indexed, not 0-indexed (i.e., it is in `range(1,
    len(topics) + 1)`).

    Parameters
    ----------
    topic_id: int
        The ID of the topic to consider.
    within_top_n: int, optional
        How many of each `ignis.corpus.Document` object&#39;s top topics to consider.
    ignore_topics: iterable of int, optional
        Don&#39;t count any of these topics if they are within the top `n` for a
        `ignis.corpus.Document`.

        E.g., for a `ignis.corpus.Document` with top topics `[5, 1, 3, ...]`,
        setting `ignore_topics` to `[5]` will consider the document&#39;s top topics
        to be `[1, 3, ...]` instead.

    Returns
    -------
    ignis.corpus.CorpusSlice
    &#34;&#34;&#34;
    return self.slice_by_topics([topic_id], within_top_n, ignore_topics)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_by_topics"><code class="name flex">
<span>def <span class="ident">slice_by_topics</span></span>(<span>self, topic_ids, within_top_n=1, ignore_topics=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General form of <code><a title="ignis.aurum.Aurum.slice_by_topic" href="#ignis.aurum.Aurum.slice_by_topic">Aurum.slice_by_topic()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>topic_ids</code></strong> :&ensp;<code>iterable</code> of <code>int</code></dt>
<dd>The IDs of the topics to consider.</dd>
<dt><strong><code>within_top_n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How many of each <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> object's top topics to consider.</dd>
<dt><strong><code>ignore_topics</code></strong> :&ensp;<code>iterable</code> of <code>int</code>, optional</dt>
<dd>
<p>Don't count any of these topics if they are within the top <code>n</code> for a
<code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code>.</p>
<p>E.g., for a <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> with top topics <code>[5, 1, 3, &hellip;]</code>,
setting <code>ignore_topics</code> to <code>[5]</code> will consider the document's top topics
to be <code>[1, 3, &hellip;]</code> instead.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_topics(self, topic_ids, within_top_n=1, ignore_topics=None):
    &#34;&#34;&#34;
    General form of `Aurum.slice_by_topic()`.

    Parameters
    ----------
    topic_ids: iterable of int
        The IDs of the topics to consider.
    within_top_n: int, optional
        How many of each `ignis.corpus.Document` object&#39;s top topics to consider.
    ignore_topics: iterable of int, optional
        Don&#39;t count any of these topics if they are within the top `n` for a
        `ignis.corpus.Document`.

        E.g., for a `ignis.corpus.Document` with top topics `[5, 1, 3, ...]`,
        setting `ignore_topics` to `[5]` will consider the document&#39;s top topics
        to be `[1, 3, ...]` instead.

    Returns
    -------
    ignis.corpus.CorpusSlice
    &#34;&#34;&#34;
    if ignore_topics is None:
        ignore_topics = []

    all_doc_ids = []
    for doc_id in self.document_ids:
        # This is a list of (&lt;topic&gt;, &lt;prob&gt;)
        doc_topics = self.get_document_topics(
            doc_id, within_top_n + len(ignore_topics)
        )
        doc_topics = sorted(doc_topics, key=lambda x: x[1], reverse=True)
        checked_topics = 0
        for topic, prob in doc_topics:
            if topic not in ignore_topics:
                # We&#39;ve seen one more topic for this document
                checked_topics += 1

            if checked_topics &gt; within_top_n:
                # Exceeded the topic check limit for this document
                break

            if topic in topic_ids:
                # Add it and go to the next document, we&#39;re done here
                all_doc_ids.append(doc_id)
                break

    return self.slice_by_ids(all_doc_ids)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_filter"><code class="name flex">
<span>def <span class="ident">slice_filter</span></span>(<span>self, filter_fn, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset using some custom <code>filter_fn</code>.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_filter" href="corpus.html#ignis.corpus.Corpus.slice_filter">Corpus.slice_filter()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_filter(self, filter_fn, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset using some custom `filter_fn`.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_filter()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_filter(filter_fn)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_without_text_string"><code class="name flex">
<span>def <span class="ident">slice_without_text_string</span></span>(<span>self, text_string, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset by removing <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> objects
that contain the given text string.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_without_text_string" href="corpus.html#ignis.corpus.Corpus.slice_without_text_string">Corpus.slice_without_text_string()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_without_text_string(self, text_string, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
    that contain the given text string.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_without_text_string()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_without_text_string(text_string)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_without_text_strings"><code class="name flex">
<span>def <span class="ident">slice_without_text_strings</span></span>(<span>self, text_strings, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset by removing <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> objects
that contain any of the given text strings.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_without_text_strings" href="corpus.html#ignis.corpus.Corpus.slice_without_text_strings">Corpus.slice_without_text_strings()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_without_text_strings(self, text_strings, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
    that contain any of the given text strings.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_without_text_strings()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_without_text_strings(text_strings)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_without_token"><code class="name flex">
<span>def <span class="ident">slice_without_token</span></span>(<span>self, token, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset by removing <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> objects
that contain the given token.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_without_token" href="corpus.html#ignis.corpus.Corpus.slice_without_token">Corpus.slice_without_token()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_without_token(self, token, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
    that contain the given token.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_without_token()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_without_token(token)</code></pre>
</details>
</dd>
<dt id="ignis.aurum.Aurum.slice_without_tokens"><code class="name flex">
<span>def <span class="ident">slice_without_tokens</span></span>(<span>self, tokens, include_root=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice the model's input dataset by removing <code><a title="ignis.corpus.Document" href="corpus.html#ignis.corpus.Document">Document</a></code> objects
that contain any of the given tokens.</p>
<p>If <code>include_root</code> is True, will slice the full base <code><a title="ignis.corpus.Corpus" href="corpus.html#ignis.corpus.Corpus">Corpus</a></code>
instead of just the model's current <code><a title="ignis.corpus.CorpusSlice" href="corpus.html#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p>See <code><a title="ignis.corpus.Corpus.slice_without_tokens" href="corpus.html#ignis.corpus.Corpus.slice_without_tokens">Corpus.slice_without_tokens()</a></code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_without_tokens(self, tokens, include_root=False):
    &#34;&#34;&#34;
    Slice the model&#39;s input dataset by removing `ignis.corpus.Document` objects
    that contain any of the given tokens.

    If `include_root` is True, will slice the full base `ignis.corpus.Corpus`
    instead of just the model&#39;s current `ignis.corpus.CorpusSlice`.

    See `ignis.corpus.Corpus.slice_without_tokens()` for more details.
    &#34;&#34;&#34;
    base_slice = self.corpus_slice
    if include_root:
        base_slice = base_slice.root

    return base_slice.slice_without_tokens(tokens)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="padding: 1em 0.5em">
<a href="/ignis-tm/ignis">
<div style="display: flex; align-items: center">
<img src="/ignis-tm/images/logo.png" alt="Ignis" height="50"/>
<span style="font-size: 2em; font-weight: 700; margin-left: 0.75em">Ignis</span>
</div>
</a>
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ignis" href="index.html">ignis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ignis.aurum.load_results" href="#ignis.aurum.load_results">load_results</a></code></li>
<li><code><a title="ignis.aurum.show_visualisations" href="#ignis.aurum.show_visualisations">show_visualisations</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ignis.aurum.Aurum" href="#ignis.aurum.Aurum">Aurum</a></code></h4>
<ul class="">
<li><code><a title="ignis.aurum.Aurum.document_ids" href="#ignis.aurum.Aurum.document_ids">document_ids</a></code></li>
<li><code><a title="ignis.aurum.Aurum.export_visualisation" href="#ignis.aurum.Aurum.export_visualisation">export_visualisation</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_coherence" href="#ignis.aurum.Aurum.get_coherence">get_coherence</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_document" href="#ignis.aurum.Aurum.get_document">get_document</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_document_top_topic" href="#ignis.aurum.Aurum.get_document_top_topic">get_document_top_topic</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_document_topics" href="#ignis.aurum.Aurum.get_document_topics">get_document_topics</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_num_topics" href="#ignis.aurum.Aurum.get_num_topics">get_num_topics</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_topic_documents" href="#ignis.aurum.Aurum.get_topic_documents">get_topic_documents</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_topic_labels" href="#ignis.aurum.Aurum.get_topic_labels">get_topic_labels</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_topic_words" href="#ignis.aurum.Aurum.get_topic_words">get_topic_words</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_vis_data" href="#ignis.aurum.Aurum.get_vis_data">get_vis_data</a></code></li>
<li><code><a title="ignis.aurum.Aurum.get_visualisation_html" href="#ignis.aurum.Aurum.get_visualisation_html">get_visualisation_html</a></code></li>
<li><code><a title="ignis.aurum.Aurum.init_labeller" href="#ignis.aurum.Aurum.init_labeller">init_labeller</a></code></li>
<li><code><a title="ignis.aurum.Aurum.init_vis" href="#ignis.aurum.Aurum.init_vis">init_vis</a></code></li>
<li><code><a title="ignis.aurum.Aurum.nb_explore_topics" href="#ignis.aurum.Aurum.nb_explore_topics">nb_explore_topics</a></code></li>
<li><code><a title="ignis.aurum.Aurum.resuggest_num_topics" href="#ignis.aurum.Aurum.resuggest_num_topics">resuggest_num_topics</a></code></li>
<li><code><a title="ignis.aurum.Aurum.retrain_model" href="#ignis.aurum.Aurum.retrain_model">retrain_model</a></code></li>
<li><code><a title="ignis.aurum.Aurum.save" href="#ignis.aurum.Aurum.save">save</a></code></li>
<li><code><a title="ignis.aurum.Aurum.show_visualisation" href="#ignis.aurum.Aurum.show_visualisation">show_visualisation</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_by_ids" href="#ignis.aurum.Aurum.slice_by_ids">slice_by_ids</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_by_text_string" href="#ignis.aurum.Aurum.slice_by_text_string">slice_by_text_string</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_by_text_strings" href="#ignis.aurum.Aurum.slice_by_text_strings">slice_by_text_strings</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_by_token" href="#ignis.aurum.Aurum.slice_by_token">slice_by_token</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_by_tokens" href="#ignis.aurum.Aurum.slice_by_tokens">slice_by_tokens</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_by_topic" href="#ignis.aurum.Aurum.slice_by_topic">slice_by_topic</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_by_topics" href="#ignis.aurum.Aurum.slice_by_topics">slice_by_topics</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_filter" href="#ignis.aurum.Aurum.slice_filter">slice_filter</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_without_text_string" href="#ignis.aurum.Aurum.slice_without_text_string">slice_without_text_string</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_without_text_strings" href="#ignis.aurum.Aurum.slice_without_text_strings">slice_without_text_strings</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_without_token" href="#ignis.aurum.Aurum.slice_without_token">slice_without_token</a></code></li>
<li><code><a title="ignis.aurum.Aurum.slice_without_tokens" href="#ignis.aurum.Aurum.slice_without_tokens">slice_without_tokens</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>