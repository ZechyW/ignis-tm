<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ignis.corpus API documentation</title>
<meta name="description" content="`ignis.corpus.Corpus` and `ignis.corpus.CorpusSlice` instances are containers for
tracking the `ignis.corpus.Document` objects in a dataset." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
</header>
<section id="section-intro">
<p><code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> and <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> instances are containers for
tracking the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects in a dataset.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
`ignis.corpus.Corpus` and `ignis.corpus.CorpusSlice` instances are containers for
tracking the `ignis.corpus.Document` objects in a dataset.
&#34;&#34;&#34;

import bz2
import collections
import json
import pathlib
import pickle
import re
import uuid

from bs4 import BeautifulSoup


class Corpus:
    &#34;&#34;&#34;
    Conceptually, `Corpus` objects contain the full amount of data for a given dataset.

    Some subset of the `Corpus` (up to the full `Corpus` itself) must be sliced into a
    `CorpusSlice` to perform topic modelling over the data, and these `CorpusSlice`
    objects can be iteratively expanded or contracted freely within the full set
    of `Corpus` data.

    The same `Corpus` will be used even as sub-slices of the data go through iterative
    modelling -- Smaller sets of `Document` objects will just be selected by ID.

    Note: `Document` objects in a `Corpus` are loosely kept in insertion order,
    but they are shuffled when sliced into `CorpusSlice` objects (viz., they are
    sorted by their randomly-generated IDs).

    Stop words are also managed at the (root) `Corpus` level -- Whenever `Document`
    objects are retrieved via `Corpus.get_document()`, stop words are removed from
    their tokens at run-time.

    Parameters
    ----------
    stop_words: set of str, optional
        The initial list of corpus-level stop words, if any.

    Attributes
    ----------
    root: Corpus
        A reference to this base `Corpus` for bookkeeping so that slicing can be done
        with both `Corpus` and `CorpusSlice` instances.
    &#34;&#34;&#34;

    def __init__(self, stop_words=None):
        self.root = self
        if stop_words is not None:
            self._stop_words = set(stop_words)
        else:
            self._stop_words = set()
        self._documents = collections.OrderedDict()

    # --------------------
    # Data manipulation
    def add_doc(self, tokens, metadata=None, display_str=None, plain_text=None):
        &#34;&#34;&#34;
        Creates a new `Document` with the given parameters and starts tracking it.

        Parameters
        ----------
        tokens: iterable of str
            The individual content tokens in the given document; will be fed directly
            into the various topic modelling algorithms.

            Assumed to have already undergone any necessary pre-processing.
        metadata: dict, optional
            A general-purpose dictionary containing any metadata the user wants to
            track.
        display_str: str, optional
            The content of the document, as a single string containing any necessary
            markup or other formatting for human-readable display. By default,
            `display_str` is assumed to contain a HTML representation of the document
            (e.g., when the document is rendered via
            `ignis.aurum.Aurum.nb_explore_topics()`), but a custom display function
            can be passed where necessary.

            If `None`, will use the document&#39;s tokens joined with single spaces.
        plain_text: str, optional
            The full text of the given document as a single normalised string.

            If `plain_text` is `None`, `display_str` is assumed to contain a HTML
            representation of the document, and a corresponding plain-text
            representation is automatically generated via `BeautifulSoup` when the
            attribute is first accessed.

        Returns
        -------
        uuid.UUID
            The ID for the added `Document`.
        &#34;&#34;&#34;
        if len(tokens) == 0:
            raise RuntimeError(&#34;Cannot add a Document with no tokens to a Corpus.&#34;)

        if metadata is None:
            metadata = collections.OrderedDict()
        if display_str is None:
            display_str = &#34; &#34;.join(tokens)
        doc = Document(tokens, metadata, display_str, plain_text)
        if doc.id in self._documents:
            raise RuntimeError(
                f&#34;This Document&#39;s hash is already present in the Corpus; it may be a &#34;
                f&#34;duplicate. Ignoring.\n&#34;
                f&#34;(If this is a genuine hash collision, create a new Document with &#34;
                f&#34;different metadata values and try adding it again.)\n&#34;
                f&#34;{doc.id}\n&#34;
                f&#34;{doc.tokens}{doc.metadata}{doc.display_str}&#34;
            )
        self._documents[doc.id] = doc

        # Impose Corpus stop word list
        # We pass the actual private `_stop_words` set by reference so that
        # modifications to the root corpus stop word list will automatically
        # propagate to all children Documents and CorpusSlices.
        self._documents[doc.id].stop_words = self.root._stop_words

        return doc.id

    def save(self, filename):
        &#34;&#34;&#34;
        Saves the `Corpus` or `CorpusSlice` object to the given file.
        Essentially uses a bz2-compressed Pickle format.

        We recommend using _.corpus_ as the canonical file extension for `Corpus`
        objects and _.slice_ as the canonical file extension for `CorpusSlice` objects,
        but this is not strictly enforced by the library.

        Parameters
        ----------
        filename: str or pathlib.Path
            File to save the `Corpus` or `CorpusSlice` to.
        &#34;&#34;&#34;
        filename = pathlib.Path(filename)
        with bz2.open(filename, &#34;wb&#34;) as fp:
            pickle.dump(self, fp)

    def concat(self, *other_corpora):
        &#34;&#34;&#34;
        Consolidates two or more separate `Corpus` objects into a single `Corpus`.

        Functionally different from the `CorpusSlice.concat()` method, which
        consolidates two slices that necessarily come from the same single `Corpus`.

        No ID collision checks are done as part of the concatenation, but these
        should be highly improbable to happen with UUIDs.

        The stop word lists from all the concatenated `Corpus` objects are combined
        to form the stop word list for the final `Corpus`.

        Note: The `+` operator can also be used to concatenate `Corpus` objects.

        Parameters
        ----------
        *other_corpora: iterable of Corpus
            The other `Corpus` object(s) to include.

        Returns
        -------
        Corpus
        &#34;&#34;&#34;
        # Sanity check
        for other_corpus in other_corpora:
            if not type(other_corpus) is Corpus:
                raise RuntimeError(
                    &#34;Corpus objects can only be concatenated with other Corpus &#34;
                    &#34;objects.&#34;
                )

        # Consolidate
        new_corpus = Corpus()

        # Because we are touching the private `._documents` store directly, we also
        # need to manually handle stop word lists.
        new_corpus.add_stop_words(self.stop_words)
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            new_corpus._documents[doc.id] = doc
            new_corpus._documents[doc.id].stop_words = new_corpus.root._stop_words

        for other_corpus in other_corpora:
            new_corpus.add_stop_words(other_corpus.stop_words)
            for doc_id in other_corpus.document_ids:
                doc = other_corpus.get_document(doc_id)
                new_corpus._documents[doc.id] = doc
                new_corpus._documents[doc.id].stop_words = new_corpus.root._stop_words

        # Return
        return new_corpus

    def add_stop_word(self, stop_word):
        &#34;&#34;&#34;
        Adds the given stop word to the root `Corpus` object&#39;s stop word list.

        Parameters
        ----------
        stop_word: str
        &#34;&#34;&#34;
        if not isinstance(stop_word, str):
            raise RuntimeWarning(
                &#34;Use `.add_stop_words()` to add multiple stop words at once.&#34;
            )

        self.root.add_stop_words([stop_word])

    def add_stop_words(self, stop_words):
        &#34;&#34;&#34;
        Adds the given stop words to the root `Corpus` object&#39;s stop word list.

        Parameters
        ----------
        stop_words: iterable of str
        &#34;&#34;&#34;
        if isinstance(stop_words, str):
            raise RuntimeWarning(&#34;Use `.add_stop_word()` to add a single stop word.&#34;)

        for stop_word in stop_words:
            self.root._stop_words.add(stop_word)

    def remove_stop_word(self, stop_word):
        &#34;&#34;&#34;
        Remove the given stop word from the root `Corpus` object&#39;s stop word list.

        Parameters
        ----------
        stop_word: str
        &#34;&#34;&#34;
        if not isinstance(stop_word, str):
            raise RuntimeWarning(
                &#34;Use `.remove_stop_words()` to remove multiple stop words at once.&#34;
            )

        self.root.remove_stop_words([stop_word])

    def remove_stop_words(self, stop_words):
        &#34;&#34;&#34;
        Remove the given stop words from the root `Corpus` object&#39;s stop word list.

        Parameters
        ----------
        stop_words: iterable of str
        &#34;&#34;&#34;
        if isinstance(stop_words, str):
            raise RuntimeWarning(
                &#34;Use `.remove_stop_word()` to remove a single stop word.&#34;
            )

        for stop_word in stop_words:
            self.root._stop_words.remove(stop_word)

    @property
    def stop_words(self):
        &#34;&#34;&#34;
        Return a copy of the set of stop words defined for this root `Corpus`.

        Returns
        -------
        set of str
        &#34;&#34;&#34;
        return set(self.root._stop_words)

    def __add__(self, other):
        return self.concat(other)

    def __len__(self):
        return len(self._documents)

    @property
    def document_ids(self):
        &#34;&#34;&#34;
        Get a list of the `Document` IDs tracked by this `Corpus`.

        Returns
        -------
        iterable of uuid.UUID
        &#34;&#34;&#34;
        return list(self._documents.keys())

    def get_document(self, doc_id):
        &#34;&#34;&#34;
        Return the `Document` from this `Corpus` with the given ID.

        Parameters
        ----------
        doc_id: uuid.UUID or str

        Returns
        -------
        Document
        &#34;&#34;&#34;
        if isinstance(doc_id, str):
            doc_id = uuid.UUID(doc_id)

        return self._documents[doc_id]

    # --------------------
    # Indexing and iteration
    def __getitem__(self, doc_id):
        if isinstance(doc_id, int):
            # Pick out the n-th Document in the Corpus
            return self.get_document(self.document_ids[doc_id])
        elif isinstance(doc_id, slice):
            # Pick out a slice of Documents from the Corpus
            return [
                self.get_document(slice_doc) for slice_doc in self.document_ids[doc_id]
            ]
        else:
            # Pick out the Document by ID
            return self.get_document(doc_id)

    def __iter__(self):
        for doc_id in self.document_ids:
            yield self.get_document(doc_id)

    # --------------------
    # Slicing functions
    def slice_full(self):
        &#34;&#34;&#34;
        Get a `CorpusSlice` containing all the `Document` objects in this `Corpus`.

        **Note**: This method can only be used with base `Corpus` objects, and will
        raise an error if used with a `CorpusSlice` object.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        return CorpusSlice(self, self.document_ids)

    def slice_by_ids(self, doc_ids):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with the given `Document` IDs.

        Parameters
        ----------
        doc_ids: iterable of uuid.UUID or iterable of str
            List of `Document` IDs to include.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(doc_ids, str) or isinstance(doc_ids, uuid.UUID):
            raise RuntimeWarning(
                &#34;`.slice_by_ids()` expects an iterable of Document IDs. If you are &#34;
                &#34;certain you want to create a slice containing a single Document, &#34;
                &#34;wrap it in a list or tuple before passing it as input.&#34;
            )

        # Make sure the IDs are in this instance&#39;s documents.
        for doc_id in doc_ids:
            if isinstance(doc_id, str):
                doc_id = uuid.UUID(doc_id)
            if doc_id not in self._documents:
                raise RuntimeError(
                    f&#34;There is no `Document` with ID &#39;{str(doc_id)}&#39; within the &#34;
                    f&#34;current slice.&#34;
                )

        return CorpusSlice(self.root, doc_ids)

    def slice_by_token(self, token):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain the given
        token.

        This method searches the `.tokens` property of each `Document`
        (case-insensitive). These are the words and phrases that appear as labels in
        the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

        Note that each label is a single token even if it contains spaces/multiple
        words.

        Parameters
        ----------
        token: str
            The token to search `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        if not isinstance(token, str):
            raise RuntimeWarning(
                &#34;Use `.slice_by_tokens()` to slice by multiple tokens at once.&#34;
            )

        return self.slice_by_tokens([token])

    def slice_by_tokens(self, tokens):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain at least one
        of the given tokens (an &#34;OR&#34; search).

        This method searches the `.tokens` property of each `Document`
        (case-insensitive). These are the words and phrases that appear as labels in
        the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

        Note that each label is a single token even if it contains spaces/multiple
        words.

        To slice together `Document` objects that contain multiple specific tokens (an
        &#34;AND&#34; search), you can chain multiple invocations of the single token filter.
        E.g.:
        `corpus.slice_by_token(&#34;token&#34;).slice_by_token(&#34;token 2&#34;)`.

        Parameters
        ----------
        tokens: iterable of str
            A list of the tokens to search `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(tokens, str):
            raise RuntimeWarning(&#34;Use `.slice_by_token()` to slice by a single token.&#34;)

        # By-token search matches tokens directly, ignoring case
        search_tokens = set([token.lower() for token in tokens])

        found_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            doc_tokens = set([token.lower() for token in doc.tokens])
            if len(search_tokens &amp; doc_tokens) &gt; 0:
                found_doc_ids.append(doc_id)

        return self.slice_by_ids(found_doc_ids)

    def slice_by_text_string(self, text_string):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain the given
        text string as an exact phrase match.

        This method searches the `.plain_text` property of each `Document`
        (case-insensitive). This is the full human-readable representation of the
        `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
        `Corpus.nb_explore()` widgets.

        Non-word characters at the boundaries of the text string are ignored, but any
        punctuation marks or other characters *within* the `Document` text have to be
        in the search string as well.

        For example, the multi-word text string `&#34;test this&#34;` will match against a
        `Document` with the phrase `&#34;She said, &#39;Test this!&#39;&#34;`, but will *not* match
        against a `Document` with the phrase `&#34;A test, this is.&#34;`, because of the
        intervening comma.

        To match both documents, you can perform an &#34;OR&#34; search on the individual
        words using `Corpus.slice_by_text_strings()` instead:
        `corpus_slice.slice_by_text_strings([&#34;test&#34;, &#34;this&#34;])`.

        Parameters
        ----------
        text_string: str
            The text string to search the content of `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        if not isinstance(text_string, str):
            raise RuntimeWarning(
                &#34;Use `.slice_by_text_strings()` to slice by multiple text strings.&#34;
            )

        return self.slice_by_text_strings([text_string])

    def slice_by_text_strings(self, text_strings):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain at least one of
        the given text strings (an &#34;OR&#34; search).

        This method searches the `.plain_text` property of each `Document`
        (case-insensitive). This is the full human-readable representation of the
        `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
        `Corpus.nb_explore()` widgets.

        Non-word characters at the boundaries of each text string are ignored.

        To slice together `Document` objects that contain multiple specific text
        strings (an &#34;AND&#34; search), you can chain multiple invocations of the single
        text string filter.
        E.g.:
        `corpus.slice_by_text_string(&#34;exact phrase&#34;).slice_by_text_string(&#34;another
        exact phrase&#34;)`.

        Parameters
        ----------
        text_strings: iterable of str
            A list of the text strings to search the content of `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(text_strings, str):
            raise RuntimeWarning(
                &#34;Use `.slice_by_text_string()` to slice by a single text string.&#34;
            )

        # Plain-text search performs a regex text search, looking for `text_string`
        # matches that start/end on word boundaries.
        search_patterns = [
            re.compile(fr&#34;(\b|\s|^){re.escape(text_string)}(\b|\s|$)&#34;, re.IGNORECASE)
            for text_string in text_strings
        ]

        found_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            doc_text = doc.plain_text

            found_pattern = False
            for pattern in search_patterns:
                if pattern.search(doc_text):
                    found_pattern = True
                    break

            if found_pattern:
                found_doc_ids.append(doc_id)

        return self.slice_by_ids(found_doc_ids)

    def slice_without_token(self, token):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` by removing `Document` objects that contain the given
        token.

        This method searches the `.tokens` property of each `Document`
        (case-insensitive). These are the words and phrases that appear as labels in
        the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

        Note that each label is a single token even if it contains spaces/multiple
        words.

        Parameters
        ----------
        token: str
            The token to search `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        if not isinstance(token, str):
            raise RuntimeWarning(
                &#34;Use `.slice_without_tokens()` to slice using multiple tokens at once.&#34;
            )

        return self.slice_without_tokens([token])

    def slice_without_tokens(self, tokens):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` by removing `Document` objects that contain any of
        the given tokens (an &#34;OR&#34; search).

        This method searches the `.tokens` property of each `Document`
        (case-insensitive). These are the words and phrases that appear as labels in
        the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

        Note that each label is a single token even if it contains spaces/multiple
        words.

        To slice out `Document` objects that contain multiple specific tokens (an &#34;AND&#34;
        search), you can chain multiple invocations of the single token filter.
        E.g.:
        `corpus.slice_without_token(&#34;token&#34;).slice_without_token(&#34;token 2&#34;)`.

        Parameters
        ----------
        tokens: iterable of str
            A list of the tokens to search `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(tokens, str):
            raise RuntimeWarning(
                &#34;Use `.slice_without_token()` to slice using a single token.&#34;
            )

        # By-token search matches tokens directly, ignoring case
        search_tokens = set([token.lower() for token in tokens])

        found_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            doc_tokens = set([token.lower() for token in doc.tokens])
            if len(search_tokens &amp; doc_tokens) == 0:
                found_doc_ids.append(doc_id)

        return self.slice_by_ids(found_doc_ids)

    def slice_without_text_string(self, text_string):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain the given
        text string removed.

        This method searches the `.plain_text` property of each `Document`
        (case-insensitive). This is the full human-readable representation of the
        `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
        `Corpus.nb_explore()` widgets.

        Non-word characters at the boundaries of the text string are ignored, but any
        punctuation marks or other characters *within* the `Document` text have to be
        in the search string as well.

        For example, the multi-word text string `&#34;test this&#34;` will match against a
        `Document` with the phrase `&#34;She said, &#39;Test this!&#39;&#34;`, but will *not* match
        against a `Document` with the phrase `&#34;A test, this is.&#34;`, because of the
        intervening comma.

        To match both documents, you can perform an &#34;OR&#34; search on the individual
        words using `Corpus.slice_without_text_strings()` instead:
        `corpus_slice.slice_without_text_strings([&#34;test&#34;, &#34;this&#34;])`.

        Parameters
        ----------
        text_string: str
            The text string to search the content of `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        if not isinstance(text_string, str):
            raise RuntimeWarning(
                &#34;Use `.slice_without_text_strings()` to slice using multiple text &#34;
                &#34;strings at once.&#34;
            )

        return self.slice_without_text_strings([text_string])

    def slice_without_text_strings(self, text_strings):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` by removing `Document` objects that contain any of
        the given text strings (an &#34;OR&#34; search).

        This method searches the `.plain_text` property of each `Document`
        (case-insensitive). This is the full human-readable representation of the
        `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
        `Corpus.nb_explore()` widgets.

        Non-word characters at the boundaries of each text string are ignored.

        To slice out `Document` objects that contain multiple specific text strings
        (an &#34;AND&#34; search), you can chain multiple invocations of the single text string
        filter.
        E.g.:
        `corpus.slice_without_text_string(&#34;exact phrase&#34;).slice_without_text_string(
        &#34;another exact phrase&#34;)`.

        Parameters
        ----------
        text_strings: iterable of str
            A list of the text strings to search the content of `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(text_strings, str):
            raise RuntimeWarning(
                &#34;Use `.slice_without_text_string()` to slice using a single text &#34;
                &#34;string.&#34;
            )

        # Plain-text search performs a regex text search, looking for `text_string`
        # matches that start/end on word boundaries or whitespace.
        search_patterns = [
            re.compile(fr&#34;(\b|\s|^){re.escape(text_string)}(\b|\s|$)&#34;, re.IGNORECASE)
            for text_string in text_strings
        ]

        found_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            doc_text = doc.plain_text

            found_pattern = False
            for pattern in search_patterns:
                if pattern.search(doc_text):
                    found_pattern = True
                    break

            if not found_pattern:
                found_doc_ids.append(doc_id)

        return self.slice_by_ids(found_doc_ids)

    def slice_filter(self, filter_fn):
        &#34;&#34;&#34;
        Slices using a custom `filter_fn` that receives one argument, a single
        `Document`.

        Returns a new `CorpusSlice` with the `Document` objects that `filter_fn`
        returns `True` for.

        Parameters
        ----------
        filter_fn: function
            The filter function.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        filtered_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            if filter_fn(doc):
                filtered_doc_ids.append(doc_id)

        return self.slice_by_ids(filtered_doc_ids)

    def nb_explore(
        self,
        doc_sort_key=None,
        reverse=False,
        display_fn=None,
        max_display_length=50000,
        metadata_full_doc_link=&#34;filename&#34;,
    ):
        &#34;&#34;&#34;
        Convenience function that creates an interactive Jupyter notebook widget for
        exploring the `Document` objects tracked by this `Corpus` or `CorpusSlice`.

        `Document` objects do not have any sort order imposed on them by default,
        but a custom sorting function can be passed via `doc_sort_key` if necessary.

        Parameters
        ----------
        doc_sort_key: fn, optional
            If specified, will sort `Document` objects using this key when displaying
            them.
        reverse: bool, optional
            Reverses the sort direction for `doc_sort_key`, if specified.
        display_fn: fn, optional
            Custom display function that receives an individual `Document` as input,
            and should display the `Document` in human-readable form as a side effect.

            If unset, will assume that the human-readable representation of the
            `Document` is in HTML format and display it accordingly.
        max_display_length: int, optional
            Maximum length (in characters) to display from the `Document` object&#39;s
            human-readable representation.  If the `Document` object&#39;s human-readable
            representation is longer than this limit, a link will be generated to
            view the full human-readable representation in a new window.

            No effect if `display_fn` is set.
        metadata_full_doc_link: str, optional
            If `max_display_length` is exceeded, this key is used to get the path to
            the full human-readable representation from the `Document` object&#39;s
            metadata dictionary.

            No effect if `display_fn` is set.
        &#34;&#34;&#34;
        import ipywidgets
        from IPython.core.display import display, HTML
        import ignis.util.jupyter_styles

        # Set up widget styling
        # noinspection PyTypeChecker
        display(HTML(ignis.util.jupyter_styles.jupyter_output_style))

        if len(self) == 0:
            print(&#34;This Corpus or CorpusSlice contains no documents.&#34;)
            return

        docs = list(self)

        if doc_sort_key is not None:
            docs = sorted(docs, key=doc_sort_key, reverse=reverse)

        def show_doc(index=1):
            # Start `index` from 1 for user-friendliness
            print(f&#34;[Total documents: {len(docs)}]\n&#34;)
            doc = docs[index - 1]

            if display_fn is None:
                # Default HTML display
                print(f&#34;ID: {doc.id}&#34;)
                if metadata_full_doc_link in doc.metadata:
                    print(f&#34;Full document: {doc.metadata[metadata_full_doc_link]}&#34;)

                # Jupyter notebooks will interpret anything between $ signs as LaTeX
                # formulae when rendering HTML output, so we need to replace them
                # with escaped $ signs (only in Jupyter environments)
                display_str = doc.display_str.replace(&#34;$&#34;, r&#34;\$&#34;)

                # Length check
                if len(display_str) &gt; max_display_length:
                    display_str = (
                        f&#34;&lt;p&gt;&#34;
                        f&#34;&lt;b&gt;Document too long to display in full - &#34;
                        f&#34;Showing first {max_display_length} characters.&lt;/b&gt;&#34;
                        f&#34;&lt;/p&gt;&#34;
                        f&#34;&lt;p&gt;&#34;
                        f&#34;&lt;a href=&#34;
                        f&#34;&#39;{doc.metadata[metadata_full_doc_link]}&#39; &#34;
                        f&#34;target=&#39;_blank&#39;&gt;&#34;
                        f&#34;Click here&#34;
                        f&#34;&lt;/a&gt; to open the full document in a new tab/window.&#34;
                        f&#34;&lt;/p&gt;&#34;
                        f&#34;&lt;hr/&gt;&#34; + display_str[:max_display_length]
                    )

                # noinspection PyTypeChecker
                display(HTML(display_str))
            else:
                # User-provided display function
                display_fn(doc)

        # Control and output widgets for the document viewer
        slider = ipywidgets.IntSlider(
            description=&#34;Document&#34;,
            min=1,
            max=len(docs),
            continuous_update=False,
            layout=ignis.util.jupyter_styles.slider_layout,
            style=ignis.util.jupyter_styles.slider_style,
        )
        text = ipywidgets.BoundedIntText(
            min=1, max=len(docs), layout=ignis.util.jupyter_styles.slider_text_layout
        )
        ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
        ui = ipywidgets.HBox([slider, text])
        out = ipywidgets.interactive_output(show_doc, {&#34;index&#34;: slider})
        # noinspection PyTypeChecker
        display(ui, out)


class CorpusSlice(Corpus):
    &#34;&#34;&#34;
    Contains some subset of the `Document` objects in a `Corpus`, and keeps a reference
    to the root `Corpus` for bookkeeping and iteration.

    All the `ignis` topic models take `CorpusSlice` objects as input.

    `CorpusSlice` is a subclass of `Corpus`, so the same slicing methods can be used
    with instances of both classes. To restart the slicing process from the full
    base `Corpus`, you can use the `.root` property of a `CorpusSlice` object.
    (E.g., `corpus_slice.root.&lt;method&gt;()`.)

    Parameters
    ----------
    root: Corpus
        The root `Corpus` instance for this slice.
    slice_ids: iterable of uuid.UUID or iterable of str
        The IDs for the `Document` objects to include in this slice.

        These are canonically instances of `uuid.UUID`, but a list of strings can
        also be passed (e.g., when instantiating `CorpusSlice` objects interactively).

    Attributes
    ----------
    root: Corpus
        A reference to the base `Corpus` for bookkeeping and slicing/iteration.
    &#34;&#34;&#34;

    def __init__(self, root, slice_ids):
        super().__init__()

        self.root = root
        self._documents = collections.OrderedDict()

        slice_ids.sort()
        for slice_id in slice_ids:
            if isinstance(slice_id, str):
                slice_id = uuid.UUID(slice_id)
            self._documents[slice_id] = root.get_document(slice_id)

    def slice_full(self):
        # This method can only be used with base `Corpus` objects, and not
        # `CorpusSlice` objects.
        raise RuntimeError(
            &#34;The `.slice_full()` method can only be used with `Corpus` objects, &#34;
            &#34;not `CorpusSlice` objects.&#34;
        )

    def concat(self, *other_slices):
        &#34;&#34;&#34;
        Returns a new `CorpusSlice` that has the `Document` objects from this instance
        and all the other specified `CorpusSlice` objects combined.

        Only `CorpusSlice` objects with the same root `Corpus` can be concatenated.

        Note: The `+` operator can also be used to concatenate `CorpusSlice` objects.

        Parameters
        ----------
        *other_slices: iterable of CorpusSlice
            The other `CorpusSlice` object(s) to include.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        new_slice_ids = set(self.document_ids)

        for other_slice in other_slices:
            if not type(other_slice) is CorpusSlice:
                raise RuntimeError(
                    &#34;CorpusSlices can only be concatenated with other CorpusSlices.&#34;
                )

            if other_slice.root != self.root:
                raise RuntimeError(
                    &#34;CorpusSlices can only be concatenated if they have the same root &#34;
                    &#34;Corpus.&#34;
                )

            slice_ids = set(other_slice.document_ids)
            new_slice_ids = new_slice_ids | slice_ids

        new_slice_ids = list(new_slice_ids)

        return CorpusSlice(self.root, new_slice_ids)

    def __add__(self, other):
        return self.concat(other)

    def __eq__(self, other):
        return (
            type(other) is CorpusSlice
            and self.root == other.root
            and set(self.document_ids) == set(other.document_ids)
        )


class Document(object):
    &#34;&#34;&#34;
    `Document` objects hold the textual content of each entry in the `Corpus`, as well
    as any relevant metadata.

    Parameters
    ----------
    tokens: iterable of str
        The individual content tokens in the given document, which will be fed
        directly into the various topic modelling algorithms.

        Assumed to have already undergone any necessary pre-processing except
        stop word removal, which will be done at run-time whenever `Document.tokens` is
        accessed.
    metadata: dict
        A general-purpose dictionary containing any metadata the user wants to
        track.
    display_str: str
        The content of the document, as a single string containing any necessary
        markup or other formatting for human-readable display. By default,
        `display_str` is assumed to contain a HTML representation of the document
        (e.g., when the document is rendered in
        `ignis.aurum.Aurum.nb_explore_topics()`), but a custom display function can
        be passed where necessary.
    plain_text: str, optional
        The full text of the given document as a single normalised string.

        If `plain_text` is None, `display_str` is assumed to contain a HTML
        representation of the document, and a corresponding plain-text representation is
        automatically generated via BeautifulSoup when the attribute is first accessed.

    Attributes
    ----------
    stop_words: set of str
        The set of current stop words for this `Document` object. When a `Document` is
        added to a `Corpus` via `Corpus.add_doc()`, this becomes a reference to the
        root `Corpus` object&#39;s list of stop words.
        Any items in this set of stop words will be removed when this `Document`
        object&#39;s `tokens` property is accessed.
    &#34;&#34;&#34;

    # Let&#39;s make Document IDs deterministic on their data, so that multiple runs of a
    # Corpus creation script don&#39;t generate different IDs.
    # We will create a UUID5 for each Document against this fixed namespace:
    ignis_uuid_namespace = uuid.UUID(&#34;58ca78f2-0347-4b96-b2e7-63796bf87889&#34;)
    &#34;&#34;&#34;The UUID5 namespace for generating deterministic `Document` IDs.&#34;&#34;&#34;

    def __init__(self, tokens, metadata, display_str, plain_text=None):
        self.raw_tokens = tokens
        self.metadata = metadata
        self.display_str = display_str
        self.plain_text = plain_text
        self.stop_words = set()

        data = f&#34;{tokens}{metadata}{display_str}&#34;
        self.id = uuid.uuid5(Document.ignis_uuid_namespace, data)

    def __setstate__(self, state):
        # Called when unpickling Document objects.
        # Ensure that `raw_tokens` is set properly when loading Corpus files saved
        # using the previous format (&lt; v1.5.0)
        if &#34;tokens&#34; in state and &#34;raw_tokens&#34; not in state:
            state[&#34;raw_tokens&#34;] = state[&#34;tokens&#34;]
        self.__dict__.update(state)

    @property
    def tokens(self):
        return [token for token in self.raw_tokens if token not in self.stop_words]

    def __str__(self):
        metadata = json.dumps(self.metadata, indent=2)

        truncated = []
        for line in metadata.splitlines():
            if len(line) &gt; 120:
                truncated.append(f&#34;{line[:120]}...&#34;)
            else:
                truncated.append(line)
        metadata = &#34;\n&#34;.join(truncated)

        return f&#34;ID: {self.id}\n\nMetadata: {metadata}\n\n&#34; f&#34;{self.display_str}&#34;

    def __getattribute__(self, item):
        if item == &#34;plain_text&#34; and object.__getattribute__(self, &#34;plain_text&#34;) is None:
            # There is no `plain_text` set for this document; assume that
            # `display_str` contains a HTML representation of the document.
            soup = BeautifulSoup(self.display_str, &#34;lxml&#34;)

            # The text returned by BeautifulSoup might contain whitespace --
            # Concatenate, split, and concatenate again to normalise the spacing
            self.plain_text = &#34; &#34;.join(soup.get_text().split())
            return self.plain_text
        return object.__getattribute__(self, item)

    def __repr__(self):
        return str(self)


# noinspection PyProtectedMember
def load_corpus(filename):
    &#34;&#34;&#34;
    Loads a `ignis.corpus.Corpus` object from the given file.

    Parameters
    ----------
    filename: str or pathlib.Path
        The file to load the `ignis.corpus.Corpus` object from.

    Returns
    -------
    ignis.corpus.Corpus
    &#34;&#34;&#34;
    with bz2.open(filename, &#34;rb&#34;) as fp:
        loaded = pickle.load(fp)

    if not type(loaded) is Corpus:
        raise ValueError(f&#34;File does not contain a `Corpus` object: &#39;{filename}&#39;&#34;)

    # Re-initialise the `Corpus` with all `Documents` and the dynamic stop word list.
    new_corpus = Corpus()
    if hasattr(loaded, &#34;_stop_words&#34;):
        # Copy stop words, if they are set
        new_corpus._stop_words = set(loaded._stop_words)
    if hasattr(loaded, &#34;documents&#34;):
        # Old version - `.documents` was directly accessible.
        docs = loaded.documents.values()
    else:
        # New version - documents can only be retrieved via `get_document()`
        docs = loaded._documents.values()
    for doc in docs:
        # `Document` objects are un-pickled separately; `Document.__setstate__()`
        # ensures that the `raw_tokens` attribute is set appropriately.
        new_corpus.add_doc(
            doc.raw_tokens, doc.metadata, doc.display_str, doc.plain_text
        )

    return new_corpus


def load_slice(filename):
    &#34;&#34;&#34;
    Loads a `ignis.corpus.CorpusSlice` object from the given file.

    Parameters
    ----------
    filename: str or pathlib.Path
        The file to load the `ignis.corpus.CorpusSlice` object from.

    Returns
    -------
    ignis.corpus.CorpusSlice
    &#34;&#34;&#34;
    with bz2.open(filename, &#34;rb&#34;) as fp:
        loaded = pickle.load(fp)

    if not type(loaded) is CorpusSlice:
        raise ValueError(f&#34;File does not contain a `CorpusSlice` object: &#39;{filename}&#39;&#34;)

    return loaded</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ignis.corpus.load_corpus"><code class="name flex">
<span>def <span class="ident">load_corpus</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> object from the given file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path</code></dt>
<dd>The file to load the <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> object from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_corpus(filename):
    &#34;&#34;&#34;
    Loads a `ignis.corpus.Corpus` object from the given file.

    Parameters
    ----------
    filename: str or pathlib.Path
        The file to load the `ignis.corpus.Corpus` object from.

    Returns
    -------
    ignis.corpus.Corpus
    &#34;&#34;&#34;
    with bz2.open(filename, &#34;rb&#34;) as fp:
        loaded = pickle.load(fp)

    if not type(loaded) is Corpus:
        raise ValueError(f&#34;File does not contain a `Corpus` object: &#39;{filename}&#39;&#34;)

    # Re-initialise the `Corpus` with all `Documents` and the dynamic stop word list.
    new_corpus = Corpus()
    if hasattr(loaded, &#34;_stop_words&#34;):
        # Copy stop words, if they are set
        new_corpus._stop_words = set(loaded._stop_words)
    if hasattr(loaded, &#34;documents&#34;):
        # Old version - `.documents` was directly accessible.
        docs = loaded.documents.values()
    else:
        # New version - documents can only be retrieved via `get_document()`
        docs = loaded._documents.values()
    for doc in docs:
        # `Document` objects are un-pickled separately; `Document.__setstate__()`
        # ensures that the `raw_tokens` attribute is set appropriately.
        new_corpus.add_doc(
            doc.raw_tokens, doc.metadata, doc.display_str, doc.plain_text
        )

    return new_corpus</code></pre>
</details>
</dd>
<dt id="ignis.corpus.load_slice"><code class="name flex">
<span>def <span class="ident">load_slice</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> object from the given file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path</code></dt>
<dd>The file to load the <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> object from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_slice(filename):
    &#34;&#34;&#34;
    Loads a `ignis.corpus.CorpusSlice` object from the given file.

    Parameters
    ----------
    filename: str or pathlib.Path
        The file to load the `ignis.corpus.CorpusSlice` object from.

    Returns
    -------
    ignis.corpus.CorpusSlice
    &#34;&#34;&#34;
    with bz2.open(filename, &#34;rb&#34;) as fp:
        loaded = pickle.load(fp)

    if not type(loaded) is CorpusSlice:
        raise ValueError(f&#34;File does not contain a `CorpusSlice` object: &#39;{filename}&#39;&#34;)

    return loaded</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ignis.corpus.Corpus"><code class="flex name class">
<span>class <span class="ident">Corpus</span></span>
<span>(</span><span>stop_words=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Conceptually, <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> objects contain the full amount of data for a given dataset.</p>
<p>Some subset of the <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> (up to the full <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> itself) must be sliced into a
<code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> to perform topic modelling over the data, and these <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code>
objects can be iteratively expanded or contracted freely within the full set
of <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> data.</p>
<p>The same <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> will be used even as sub-slices of the data go through iterative
modelling &ndash; Smaller sets of <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects will just be selected by ID.</p>
<p>Note: <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects in a <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> are loosely kept in insertion order,
but they are shuffled when sliced into <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> objects (viz., they are
sorted by their randomly-generated IDs).</p>
<p>Stop words are also managed at the (root) <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> level &ndash; Whenever <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
objects are retrieved via <code><a title="ignis.corpus.Corpus.get_document" href="#ignis.corpus.Corpus.get_document">Corpus.get_document()</a></code>, stop words are removed from
their tokens at run-time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stop_words</code></strong> :&ensp;<code>set</code> of <code>str</code>, optional</dt>
<dd>The initial list of corpus-level stop words, if any.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code></dt>
<dd>A reference to this base <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> for bookkeeping so that slicing can be done
with both <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> and <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> instances.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Corpus:
    &#34;&#34;&#34;
    Conceptually, `Corpus` objects contain the full amount of data for a given dataset.

    Some subset of the `Corpus` (up to the full `Corpus` itself) must be sliced into a
    `CorpusSlice` to perform topic modelling over the data, and these `CorpusSlice`
    objects can be iteratively expanded or contracted freely within the full set
    of `Corpus` data.

    The same `Corpus` will be used even as sub-slices of the data go through iterative
    modelling -- Smaller sets of `Document` objects will just be selected by ID.

    Note: `Document` objects in a `Corpus` are loosely kept in insertion order,
    but they are shuffled when sliced into `CorpusSlice` objects (viz., they are
    sorted by their randomly-generated IDs).

    Stop words are also managed at the (root) `Corpus` level -- Whenever `Document`
    objects are retrieved via `Corpus.get_document()`, stop words are removed from
    their tokens at run-time.

    Parameters
    ----------
    stop_words: set of str, optional
        The initial list of corpus-level stop words, if any.

    Attributes
    ----------
    root: Corpus
        A reference to this base `Corpus` for bookkeeping so that slicing can be done
        with both `Corpus` and `CorpusSlice` instances.
    &#34;&#34;&#34;

    def __init__(self, stop_words=None):
        self.root = self
        if stop_words is not None:
            self._stop_words = set(stop_words)
        else:
            self._stop_words = set()
        self._documents = collections.OrderedDict()

    # --------------------
    # Data manipulation
    def add_doc(self, tokens, metadata=None, display_str=None, plain_text=None):
        &#34;&#34;&#34;
        Creates a new `Document` with the given parameters and starts tracking it.

        Parameters
        ----------
        tokens: iterable of str
            The individual content tokens in the given document; will be fed directly
            into the various topic modelling algorithms.

            Assumed to have already undergone any necessary pre-processing.
        metadata: dict, optional
            A general-purpose dictionary containing any metadata the user wants to
            track.
        display_str: str, optional
            The content of the document, as a single string containing any necessary
            markup or other formatting for human-readable display. By default,
            `display_str` is assumed to contain a HTML representation of the document
            (e.g., when the document is rendered via
            `ignis.aurum.Aurum.nb_explore_topics()`), but a custom display function
            can be passed where necessary.

            If `None`, will use the document&#39;s tokens joined with single spaces.
        plain_text: str, optional
            The full text of the given document as a single normalised string.

            If `plain_text` is `None`, `display_str` is assumed to contain a HTML
            representation of the document, and a corresponding plain-text
            representation is automatically generated via `BeautifulSoup` when the
            attribute is first accessed.

        Returns
        -------
        uuid.UUID
            The ID for the added `Document`.
        &#34;&#34;&#34;
        if len(tokens) == 0:
            raise RuntimeError(&#34;Cannot add a Document with no tokens to a Corpus.&#34;)

        if metadata is None:
            metadata = collections.OrderedDict()
        if display_str is None:
            display_str = &#34; &#34;.join(tokens)
        doc = Document(tokens, metadata, display_str, plain_text)
        if doc.id in self._documents:
            raise RuntimeError(
                f&#34;This Document&#39;s hash is already present in the Corpus; it may be a &#34;
                f&#34;duplicate. Ignoring.\n&#34;
                f&#34;(If this is a genuine hash collision, create a new Document with &#34;
                f&#34;different metadata values and try adding it again.)\n&#34;
                f&#34;{doc.id}\n&#34;
                f&#34;{doc.tokens}{doc.metadata}{doc.display_str}&#34;
            )
        self._documents[doc.id] = doc

        # Impose Corpus stop word list
        # We pass the actual private `_stop_words` set by reference so that
        # modifications to the root corpus stop word list will automatically
        # propagate to all children Documents and CorpusSlices.
        self._documents[doc.id].stop_words = self.root._stop_words

        return doc.id

    def save(self, filename):
        &#34;&#34;&#34;
        Saves the `Corpus` or `CorpusSlice` object to the given file.
        Essentially uses a bz2-compressed Pickle format.

        We recommend using _.corpus_ as the canonical file extension for `Corpus`
        objects and _.slice_ as the canonical file extension for `CorpusSlice` objects,
        but this is not strictly enforced by the library.

        Parameters
        ----------
        filename: str or pathlib.Path
            File to save the `Corpus` or `CorpusSlice` to.
        &#34;&#34;&#34;
        filename = pathlib.Path(filename)
        with bz2.open(filename, &#34;wb&#34;) as fp:
            pickle.dump(self, fp)

    def concat(self, *other_corpora):
        &#34;&#34;&#34;
        Consolidates two or more separate `Corpus` objects into a single `Corpus`.

        Functionally different from the `CorpusSlice.concat()` method, which
        consolidates two slices that necessarily come from the same single `Corpus`.

        No ID collision checks are done as part of the concatenation, but these
        should be highly improbable to happen with UUIDs.

        The stop word lists from all the concatenated `Corpus` objects are combined
        to form the stop word list for the final `Corpus`.

        Note: The `+` operator can also be used to concatenate `Corpus` objects.

        Parameters
        ----------
        *other_corpora: iterable of Corpus
            The other `Corpus` object(s) to include.

        Returns
        -------
        Corpus
        &#34;&#34;&#34;
        # Sanity check
        for other_corpus in other_corpora:
            if not type(other_corpus) is Corpus:
                raise RuntimeError(
                    &#34;Corpus objects can only be concatenated with other Corpus &#34;
                    &#34;objects.&#34;
                )

        # Consolidate
        new_corpus = Corpus()

        # Because we are touching the private `._documents` store directly, we also
        # need to manually handle stop word lists.
        new_corpus.add_stop_words(self.stop_words)
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            new_corpus._documents[doc.id] = doc
            new_corpus._documents[doc.id].stop_words = new_corpus.root._stop_words

        for other_corpus in other_corpora:
            new_corpus.add_stop_words(other_corpus.stop_words)
            for doc_id in other_corpus.document_ids:
                doc = other_corpus.get_document(doc_id)
                new_corpus._documents[doc.id] = doc
                new_corpus._documents[doc.id].stop_words = new_corpus.root._stop_words

        # Return
        return new_corpus

    def add_stop_word(self, stop_word):
        &#34;&#34;&#34;
        Adds the given stop word to the root `Corpus` object&#39;s stop word list.

        Parameters
        ----------
        stop_word: str
        &#34;&#34;&#34;
        if not isinstance(stop_word, str):
            raise RuntimeWarning(
                &#34;Use `.add_stop_words()` to add multiple stop words at once.&#34;
            )

        self.root.add_stop_words([stop_word])

    def add_stop_words(self, stop_words):
        &#34;&#34;&#34;
        Adds the given stop words to the root `Corpus` object&#39;s stop word list.

        Parameters
        ----------
        stop_words: iterable of str
        &#34;&#34;&#34;
        if isinstance(stop_words, str):
            raise RuntimeWarning(&#34;Use `.add_stop_word()` to add a single stop word.&#34;)

        for stop_word in stop_words:
            self.root._stop_words.add(stop_word)

    def remove_stop_word(self, stop_word):
        &#34;&#34;&#34;
        Remove the given stop word from the root `Corpus` object&#39;s stop word list.

        Parameters
        ----------
        stop_word: str
        &#34;&#34;&#34;
        if not isinstance(stop_word, str):
            raise RuntimeWarning(
                &#34;Use `.remove_stop_words()` to remove multiple stop words at once.&#34;
            )

        self.root.remove_stop_words([stop_word])

    def remove_stop_words(self, stop_words):
        &#34;&#34;&#34;
        Remove the given stop words from the root `Corpus` object&#39;s stop word list.

        Parameters
        ----------
        stop_words: iterable of str
        &#34;&#34;&#34;
        if isinstance(stop_words, str):
            raise RuntimeWarning(
                &#34;Use `.remove_stop_word()` to remove a single stop word.&#34;
            )

        for stop_word in stop_words:
            self.root._stop_words.remove(stop_word)

    @property
    def stop_words(self):
        &#34;&#34;&#34;
        Return a copy of the set of stop words defined for this root `Corpus`.

        Returns
        -------
        set of str
        &#34;&#34;&#34;
        return set(self.root._stop_words)

    def __add__(self, other):
        return self.concat(other)

    def __len__(self):
        return len(self._documents)

    @property
    def document_ids(self):
        &#34;&#34;&#34;
        Get a list of the `Document` IDs tracked by this `Corpus`.

        Returns
        -------
        iterable of uuid.UUID
        &#34;&#34;&#34;
        return list(self._documents.keys())

    def get_document(self, doc_id):
        &#34;&#34;&#34;
        Return the `Document` from this `Corpus` with the given ID.

        Parameters
        ----------
        doc_id: uuid.UUID or str

        Returns
        -------
        Document
        &#34;&#34;&#34;
        if isinstance(doc_id, str):
            doc_id = uuid.UUID(doc_id)

        return self._documents[doc_id]

    # --------------------
    # Indexing and iteration
    def __getitem__(self, doc_id):
        if isinstance(doc_id, int):
            # Pick out the n-th Document in the Corpus
            return self.get_document(self.document_ids[doc_id])
        elif isinstance(doc_id, slice):
            # Pick out a slice of Documents from the Corpus
            return [
                self.get_document(slice_doc) for slice_doc in self.document_ids[doc_id]
            ]
        else:
            # Pick out the Document by ID
            return self.get_document(doc_id)

    def __iter__(self):
        for doc_id in self.document_ids:
            yield self.get_document(doc_id)

    # --------------------
    # Slicing functions
    def slice_full(self):
        &#34;&#34;&#34;
        Get a `CorpusSlice` containing all the `Document` objects in this `Corpus`.

        **Note**: This method can only be used with base `Corpus` objects, and will
        raise an error if used with a `CorpusSlice` object.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        return CorpusSlice(self, self.document_ids)

    def slice_by_ids(self, doc_ids):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with the given `Document` IDs.

        Parameters
        ----------
        doc_ids: iterable of uuid.UUID or iterable of str
            List of `Document` IDs to include.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(doc_ids, str) or isinstance(doc_ids, uuid.UUID):
            raise RuntimeWarning(
                &#34;`.slice_by_ids()` expects an iterable of Document IDs. If you are &#34;
                &#34;certain you want to create a slice containing a single Document, &#34;
                &#34;wrap it in a list or tuple before passing it as input.&#34;
            )

        # Make sure the IDs are in this instance&#39;s documents.
        for doc_id in doc_ids:
            if isinstance(doc_id, str):
                doc_id = uuid.UUID(doc_id)
            if doc_id not in self._documents:
                raise RuntimeError(
                    f&#34;There is no `Document` with ID &#39;{str(doc_id)}&#39; within the &#34;
                    f&#34;current slice.&#34;
                )

        return CorpusSlice(self.root, doc_ids)

    def slice_by_token(self, token):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain the given
        token.

        This method searches the `.tokens` property of each `Document`
        (case-insensitive). These are the words and phrases that appear as labels in
        the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

        Note that each label is a single token even if it contains spaces/multiple
        words.

        Parameters
        ----------
        token: str
            The token to search `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        if not isinstance(token, str):
            raise RuntimeWarning(
                &#34;Use `.slice_by_tokens()` to slice by multiple tokens at once.&#34;
            )

        return self.slice_by_tokens([token])

    def slice_by_tokens(self, tokens):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain at least one
        of the given tokens (an &#34;OR&#34; search).

        This method searches the `.tokens` property of each `Document`
        (case-insensitive). These are the words and phrases that appear as labels in
        the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

        Note that each label is a single token even if it contains spaces/multiple
        words.

        To slice together `Document` objects that contain multiple specific tokens (an
        &#34;AND&#34; search), you can chain multiple invocations of the single token filter.
        E.g.:
        `corpus.slice_by_token(&#34;token&#34;).slice_by_token(&#34;token 2&#34;)`.

        Parameters
        ----------
        tokens: iterable of str
            A list of the tokens to search `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(tokens, str):
            raise RuntimeWarning(&#34;Use `.slice_by_token()` to slice by a single token.&#34;)

        # By-token search matches tokens directly, ignoring case
        search_tokens = set([token.lower() for token in tokens])

        found_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            doc_tokens = set([token.lower() for token in doc.tokens])
            if len(search_tokens &amp; doc_tokens) &gt; 0:
                found_doc_ids.append(doc_id)

        return self.slice_by_ids(found_doc_ids)

    def slice_by_text_string(self, text_string):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain the given
        text string as an exact phrase match.

        This method searches the `.plain_text` property of each `Document`
        (case-insensitive). This is the full human-readable representation of the
        `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
        `Corpus.nb_explore()` widgets.

        Non-word characters at the boundaries of the text string are ignored, but any
        punctuation marks or other characters *within* the `Document` text have to be
        in the search string as well.

        For example, the multi-word text string `&#34;test this&#34;` will match against a
        `Document` with the phrase `&#34;She said, &#39;Test this!&#39;&#34;`, but will *not* match
        against a `Document` with the phrase `&#34;A test, this is.&#34;`, because of the
        intervening comma.

        To match both documents, you can perform an &#34;OR&#34; search on the individual
        words using `Corpus.slice_by_text_strings()` instead:
        `corpus_slice.slice_by_text_strings([&#34;test&#34;, &#34;this&#34;])`.

        Parameters
        ----------
        text_string: str
            The text string to search the content of `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        if not isinstance(text_string, str):
            raise RuntimeWarning(
                &#34;Use `.slice_by_text_strings()` to slice by multiple text strings.&#34;
            )

        return self.slice_by_text_strings([text_string])

    def slice_by_text_strings(self, text_strings):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain at least one of
        the given text strings (an &#34;OR&#34; search).

        This method searches the `.plain_text` property of each `Document`
        (case-insensitive). This is the full human-readable representation of the
        `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
        `Corpus.nb_explore()` widgets.

        Non-word characters at the boundaries of each text string are ignored.

        To slice together `Document` objects that contain multiple specific text
        strings (an &#34;AND&#34; search), you can chain multiple invocations of the single
        text string filter.
        E.g.:
        `corpus.slice_by_text_string(&#34;exact phrase&#34;).slice_by_text_string(&#34;another
        exact phrase&#34;)`.

        Parameters
        ----------
        text_strings: iterable of str
            A list of the text strings to search the content of `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(text_strings, str):
            raise RuntimeWarning(
                &#34;Use `.slice_by_text_string()` to slice by a single text string.&#34;
            )

        # Plain-text search performs a regex text search, looking for `text_string`
        # matches that start/end on word boundaries.
        search_patterns = [
            re.compile(fr&#34;(\b|\s|^){re.escape(text_string)}(\b|\s|$)&#34;, re.IGNORECASE)
            for text_string in text_strings
        ]

        found_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            doc_text = doc.plain_text

            found_pattern = False
            for pattern in search_patterns:
                if pattern.search(doc_text):
                    found_pattern = True
                    break

            if found_pattern:
                found_doc_ids.append(doc_id)

        return self.slice_by_ids(found_doc_ids)

    def slice_without_token(self, token):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` by removing `Document` objects that contain the given
        token.

        This method searches the `.tokens` property of each `Document`
        (case-insensitive). These are the words and phrases that appear as labels in
        the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

        Note that each label is a single token even if it contains spaces/multiple
        words.

        Parameters
        ----------
        token: str
            The token to search `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        if not isinstance(token, str):
            raise RuntimeWarning(
                &#34;Use `.slice_without_tokens()` to slice using multiple tokens at once.&#34;
            )

        return self.slice_without_tokens([token])

    def slice_without_tokens(self, tokens):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` by removing `Document` objects that contain any of
        the given tokens (an &#34;OR&#34; search).

        This method searches the `.tokens` property of each `Document`
        (case-insensitive). These are the words and phrases that appear as labels in
        the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

        Note that each label is a single token even if it contains spaces/multiple
        words.

        To slice out `Document` objects that contain multiple specific tokens (an &#34;AND&#34;
        search), you can chain multiple invocations of the single token filter.
        E.g.:
        `corpus.slice_without_token(&#34;token&#34;).slice_without_token(&#34;token 2&#34;)`.

        Parameters
        ----------
        tokens: iterable of str
            A list of the tokens to search `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(tokens, str):
            raise RuntimeWarning(
                &#34;Use `.slice_without_token()` to slice using a single token.&#34;
            )

        # By-token search matches tokens directly, ignoring case
        search_tokens = set([token.lower() for token in tokens])

        found_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            doc_tokens = set([token.lower() for token in doc.tokens])
            if len(search_tokens &amp; doc_tokens) == 0:
                found_doc_ids.append(doc_id)

        return self.slice_by_ids(found_doc_ids)

    def slice_without_text_string(self, text_string):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` with `Document` objects that contain the given
        text string removed.

        This method searches the `.plain_text` property of each `Document`
        (case-insensitive). This is the full human-readable representation of the
        `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
        `Corpus.nb_explore()` widgets.

        Non-word characters at the boundaries of the text string are ignored, but any
        punctuation marks or other characters *within* the `Document` text have to be
        in the search string as well.

        For example, the multi-word text string `&#34;test this&#34;` will match against a
        `Document` with the phrase `&#34;She said, &#39;Test this!&#39;&#34;`, but will *not* match
        against a `Document` with the phrase `&#34;A test, this is.&#34;`, because of the
        intervening comma.

        To match both documents, you can perform an &#34;OR&#34; search on the individual
        words using `Corpus.slice_without_text_strings()` instead:
        `corpus_slice.slice_without_text_strings([&#34;test&#34;, &#34;this&#34;])`.

        Parameters
        ----------
        text_string: str
            The text string to search the content of `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        if not isinstance(text_string, str):
            raise RuntimeWarning(
                &#34;Use `.slice_without_text_strings()` to slice using multiple text &#34;
                &#34;strings at once.&#34;
            )

        return self.slice_without_text_strings([text_string])

    def slice_without_text_strings(self, text_strings):
        &#34;&#34;&#34;
        Create a new `CorpusSlice` by removing `Document` objects that contain any of
        the given text strings (an &#34;OR&#34; search).

        This method searches the `.plain_text` property of each `Document`
        (case-insensitive). This is the full human-readable representation of the
        `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
        `Corpus.nb_explore()` widgets.

        Non-word characters at the boundaries of each text string are ignored.

        To slice out `Document` objects that contain multiple specific text strings
        (an &#34;AND&#34; search), you can chain multiple invocations of the single text string
        filter.
        E.g.:
        `corpus.slice_without_text_string(&#34;exact phrase&#34;).slice_without_text_string(
        &#34;another exact phrase&#34;)`.

        Parameters
        ----------
        text_strings: iterable of str
            A list of the text strings to search the content of `Document` objects for.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        # Sanity check
        if isinstance(text_strings, str):
            raise RuntimeWarning(
                &#34;Use `.slice_without_text_string()` to slice using a single text &#34;
                &#34;string.&#34;
            )

        # Plain-text search performs a regex text search, looking for `text_string`
        # matches that start/end on word boundaries or whitespace.
        search_patterns = [
            re.compile(fr&#34;(\b|\s|^){re.escape(text_string)}(\b|\s|$)&#34;, re.IGNORECASE)
            for text_string in text_strings
        ]

        found_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            doc_text = doc.plain_text

            found_pattern = False
            for pattern in search_patterns:
                if pattern.search(doc_text):
                    found_pattern = True
                    break

            if not found_pattern:
                found_doc_ids.append(doc_id)

        return self.slice_by_ids(found_doc_ids)

    def slice_filter(self, filter_fn):
        &#34;&#34;&#34;
        Slices using a custom `filter_fn` that receives one argument, a single
        `Document`.

        Returns a new `CorpusSlice` with the `Document` objects that `filter_fn`
        returns `True` for.

        Parameters
        ----------
        filter_fn: function
            The filter function.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        filtered_doc_ids = []
        for doc_id in self.document_ids:
            doc = self.get_document(doc_id)
            if filter_fn(doc):
                filtered_doc_ids.append(doc_id)

        return self.slice_by_ids(filtered_doc_ids)

    def nb_explore(
        self,
        doc_sort_key=None,
        reverse=False,
        display_fn=None,
        max_display_length=50000,
        metadata_full_doc_link=&#34;filename&#34;,
    ):
        &#34;&#34;&#34;
        Convenience function that creates an interactive Jupyter notebook widget for
        exploring the `Document` objects tracked by this `Corpus` or `CorpusSlice`.

        `Document` objects do not have any sort order imposed on them by default,
        but a custom sorting function can be passed via `doc_sort_key` if necessary.

        Parameters
        ----------
        doc_sort_key: fn, optional
            If specified, will sort `Document` objects using this key when displaying
            them.
        reverse: bool, optional
            Reverses the sort direction for `doc_sort_key`, if specified.
        display_fn: fn, optional
            Custom display function that receives an individual `Document` as input,
            and should display the `Document` in human-readable form as a side effect.

            If unset, will assume that the human-readable representation of the
            `Document` is in HTML format and display it accordingly.
        max_display_length: int, optional
            Maximum length (in characters) to display from the `Document` object&#39;s
            human-readable representation.  If the `Document` object&#39;s human-readable
            representation is longer than this limit, a link will be generated to
            view the full human-readable representation in a new window.

            No effect if `display_fn` is set.
        metadata_full_doc_link: str, optional
            If `max_display_length` is exceeded, this key is used to get the path to
            the full human-readable representation from the `Document` object&#39;s
            metadata dictionary.

            No effect if `display_fn` is set.
        &#34;&#34;&#34;
        import ipywidgets
        from IPython.core.display import display, HTML
        import ignis.util.jupyter_styles

        # Set up widget styling
        # noinspection PyTypeChecker
        display(HTML(ignis.util.jupyter_styles.jupyter_output_style))

        if len(self) == 0:
            print(&#34;This Corpus or CorpusSlice contains no documents.&#34;)
            return

        docs = list(self)

        if doc_sort_key is not None:
            docs = sorted(docs, key=doc_sort_key, reverse=reverse)

        def show_doc(index=1):
            # Start `index` from 1 for user-friendliness
            print(f&#34;[Total documents: {len(docs)}]\n&#34;)
            doc = docs[index - 1]

            if display_fn is None:
                # Default HTML display
                print(f&#34;ID: {doc.id}&#34;)
                if metadata_full_doc_link in doc.metadata:
                    print(f&#34;Full document: {doc.metadata[metadata_full_doc_link]}&#34;)

                # Jupyter notebooks will interpret anything between $ signs as LaTeX
                # formulae when rendering HTML output, so we need to replace them
                # with escaped $ signs (only in Jupyter environments)
                display_str = doc.display_str.replace(&#34;$&#34;, r&#34;\$&#34;)

                # Length check
                if len(display_str) &gt; max_display_length:
                    display_str = (
                        f&#34;&lt;p&gt;&#34;
                        f&#34;&lt;b&gt;Document too long to display in full - &#34;
                        f&#34;Showing first {max_display_length} characters.&lt;/b&gt;&#34;
                        f&#34;&lt;/p&gt;&#34;
                        f&#34;&lt;p&gt;&#34;
                        f&#34;&lt;a href=&#34;
                        f&#34;&#39;{doc.metadata[metadata_full_doc_link]}&#39; &#34;
                        f&#34;target=&#39;_blank&#39;&gt;&#34;
                        f&#34;Click here&#34;
                        f&#34;&lt;/a&gt; to open the full document in a new tab/window.&#34;
                        f&#34;&lt;/p&gt;&#34;
                        f&#34;&lt;hr/&gt;&#34; + display_str[:max_display_length]
                    )

                # noinspection PyTypeChecker
                display(HTML(display_str))
            else:
                # User-provided display function
                display_fn(doc)

        # Control and output widgets for the document viewer
        slider = ipywidgets.IntSlider(
            description=&#34;Document&#34;,
            min=1,
            max=len(docs),
            continuous_update=False,
            layout=ignis.util.jupyter_styles.slider_layout,
            style=ignis.util.jupyter_styles.slider_style,
        )
        text = ipywidgets.BoundedIntText(
            min=1, max=len(docs), layout=ignis.util.jupyter_styles.slider_text_layout
        )
        ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
        ui = ipywidgets.HBox([slider, text])
        out = ipywidgets.interactive_output(show_doc, {&#34;index&#34;: slider})
        # noinspection PyTypeChecker
        display(ui, out)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ignis.corpus.Corpus.document_ids"><code class="name">var <span class="ident">document_ids</span></code></dt>
<dd>
<div class="desc"><p>Get a list of the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> IDs tracked by this <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>iterable</code> of <code>uuid.UUID</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def document_ids(self):
    &#34;&#34;&#34;
    Get a list of the `Document` IDs tracked by this `Corpus`.

    Returns
    -------
    iterable of uuid.UUID
    &#34;&#34;&#34;
    return list(self._documents.keys())</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.stop_words"><code class="name">var <span class="ident">stop_words</span></code></dt>
<dd>
<div class="desc"><p>Return a copy of the set of stop words defined for this root <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code> of <code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stop_words(self):
    &#34;&#34;&#34;
    Return a copy of the set of stop words defined for this root `Corpus`.

    Returns
    -------
    set of str
    &#34;&#34;&#34;
    return set(self.root._stop_words)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ignis.corpus.Corpus.add_doc"><code class="name flex">
<span>def <span class="ident">add_doc</span></span>(<span>self, tokens, metadata=None, display_str=None, plain_text=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> with the given parameters and starts tracking it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tokens</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>
<p>The individual content tokens in the given document; will be fed directly
into the various topic modelling algorithms.</p>
<p>Assumed to have already undergone any necessary pre-processing.</p>
</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>A general-purpose dictionary containing any metadata the user wants to
track.</dd>
<dt><strong><code>display_str</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>The content of the document, as a single string containing any necessary
markup or other formatting for human-readable display. By default,
<code>display_str</code> is assumed to contain a HTML representation of the document
(e.g., when the document is rendered via
<code><a title="ignis.aurum.Aurum.nb_explore_topics" href="aurum.html#ignis.aurum.Aurum.nb_explore_topics">Aurum.nb_explore_topics()</a></code>), but a custom display function
can be passed where necessary.</p>
<p>If <code>None</code>, will use the document's tokens joined with single spaces.</p>
</dd>
<dt><strong><code>plain_text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>The full text of the given document as a single normalised string.</p>
<p>If <code>plain_text</code> is <code>None</code>, <code>display_str</code> is assumed to contain a HTML
representation of the document, and a corresponding plain-text
representation is automatically generated via <code>BeautifulSoup</code> when the
attribute is first accessed.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>uuid.UUID</code></dt>
<dd>The ID for the added <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_doc(self, tokens, metadata=None, display_str=None, plain_text=None):
    &#34;&#34;&#34;
    Creates a new `Document` with the given parameters and starts tracking it.

    Parameters
    ----------
    tokens: iterable of str
        The individual content tokens in the given document; will be fed directly
        into the various topic modelling algorithms.

        Assumed to have already undergone any necessary pre-processing.
    metadata: dict, optional
        A general-purpose dictionary containing any metadata the user wants to
        track.
    display_str: str, optional
        The content of the document, as a single string containing any necessary
        markup or other formatting for human-readable display. By default,
        `display_str` is assumed to contain a HTML representation of the document
        (e.g., when the document is rendered via
        `ignis.aurum.Aurum.nb_explore_topics()`), but a custom display function
        can be passed where necessary.

        If `None`, will use the document&#39;s tokens joined with single spaces.
    plain_text: str, optional
        The full text of the given document as a single normalised string.

        If `plain_text` is `None`, `display_str` is assumed to contain a HTML
        representation of the document, and a corresponding plain-text
        representation is automatically generated via `BeautifulSoup` when the
        attribute is first accessed.

    Returns
    -------
    uuid.UUID
        The ID for the added `Document`.
    &#34;&#34;&#34;
    if len(tokens) == 0:
        raise RuntimeError(&#34;Cannot add a Document with no tokens to a Corpus.&#34;)

    if metadata is None:
        metadata = collections.OrderedDict()
    if display_str is None:
        display_str = &#34; &#34;.join(tokens)
    doc = Document(tokens, metadata, display_str, plain_text)
    if doc.id in self._documents:
        raise RuntimeError(
            f&#34;This Document&#39;s hash is already present in the Corpus; it may be a &#34;
            f&#34;duplicate. Ignoring.\n&#34;
            f&#34;(If this is a genuine hash collision, create a new Document with &#34;
            f&#34;different metadata values and try adding it again.)\n&#34;
            f&#34;{doc.id}\n&#34;
            f&#34;{doc.tokens}{doc.metadata}{doc.display_str}&#34;
        )
    self._documents[doc.id] = doc

    # Impose Corpus stop word list
    # We pass the actual private `_stop_words` set by reference so that
    # modifications to the root corpus stop word list will automatically
    # propagate to all children Documents and CorpusSlices.
    self._documents[doc.id].stop_words = self.root._stop_words

    return doc.id</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.add_stop_word"><code class="name flex">
<span>def <span class="ident">add_stop_word</span></span>(<span>self, stop_word)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the given stop word to the root <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> object's stop word list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stop_word</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stop_word(self, stop_word):
    &#34;&#34;&#34;
    Adds the given stop word to the root `Corpus` object&#39;s stop word list.

    Parameters
    ----------
    stop_word: str
    &#34;&#34;&#34;
    if not isinstance(stop_word, str):
        raise RuntimeWarning(
            &#34;Use `.add_stop_words()` to add multiple stop words at once.&#34;
        )

    self.root.add_stop_words([stop_word])</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.add_stop_words"><code class="name flex">
<span>def <span class="ident">add_stop_words</span></span>(<span>self, stop_words)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the given stop words to the root <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> object's stop word list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stop_words</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stop_words(self, stop_words):
    &#34;&#34;&#34;
    Adds the given stop words to the root `Corpus` object&#39;s stop word list.

    Parameters
    ----------
    stop_words: iterable of str
    &#34;&#34;&#34;
    if isinstance(stop_words, str):
        raise RuntimeWarning(&#34;Use `.add_stop_word()` to add a single stop word.&#34;)

    for stop_word in stop_words:
        self.root._stop_words.add(stop_word)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>self, *other_corpora)</span>
</code></dt>
<dd>
<div class="desc"><p>Consolidates two or more separate <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> objects into a single <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>.</p>
<p>Functionally different from the <code><a title="ignis.corpus.CorpusSlice.concat" href="#ignis.corpus.CorpusSlice.concat">CorpusSlice.concat()</a></code> method, which
consolidates two slices that necessarily come from the same single <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>.</p>
<p>No ID collision checks are done as part of the concatenation, but these
should be highly improbable to happen with UUIDs.</p>
<p>The stop word lists from all the concatenated <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> objects are combined
to form the stop word list for the final <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>.</p>
<p>Note: The <code>+</code> operator can also be used to concatenate <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> objects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*other_corpora</code></strong> :&ensp;<code>iterable</code> of <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code></dt>
<dd>The other <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> object(s) to include.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(self, *other_corpora):
    &#34;&#34;&#34;
    Consolidates two or more separate `Corpus` objects into a single `Corpus`.

    Functionally different from the `CorpusSlice.concat()` method, which
    consolidates two slices that necessarily come from the same single `Corpus`.

    No ID collision checks are done as part of the concatenation, but these
    should be highly improbable to happen with UUIDs.

    The stop word lists from all the concatenated `Corpus` objects are combined
    to form the stop word list for the final `Corpus`.

    Note: The `+` operator can also be used to concatenate `Corpus` objects.

    Parameters
    ----------
    *other_corpora: iterable of Corpus
        The other `Corpus` object(s) to include.

    Returns
    -------
    Corpus
    &#34;&#34;&#34;
    # Sanity check
    for other_corpus in other_corpora:
        if not type(other_corpus) is Corpus:
            raise RuntimeError(
                &#34;Corpus objects can only be concatenated with other Corpus &#34;
                &#34;objects.&#34;
            )

    # Consolidate
    new_corpus = Corpus()

    # Because we are touching the private `._documents` store directly, we also
    # need to manually handle stop word lists.
    new_corpus.add_stop_words(self.stop_words)
    for doc_id in self.document_ids:
        doc = self.get_document(doc_id)
        new_corpus._documents[doc.id] = doc
        new_corpus._documents[doc.id].stop_words = new_corpus.root._stop_words

    for other_corpus in other_corpora:
        new_corpus.add_stop_words(other_corpus.stop_words)
        for doc_id in other_corpus.document_ids:
            doc = other_corpus.get_document(doc_id)
            new_corpus._documents[doc.id] = doc
            new_corpus._documents[doc.id].stop_words = new_corpus.root._stop_words

    # Return
    return new_corpus</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.get_document"><code class="name flex">
<span>def <span class="ident">get_document</span></span>(<span>self, doc_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> from this <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> with the given ID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>doc_id</code></strong> :&ensp;<code>uuid.UUID</code> or <code>str</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_document(self, doc_id):
    &#34;&#34;&#34;
    Return the `Document` from this `Corpus` with the given ID.

    Parameters
    ----------
    doc_id: uuid.UUID or str

    Returns
    -------
    Document
    &#34;&#34;&#34;
    if isinstance(doc_id, str):
        doc_id = uuid.UUID(doc_id)

    return self._documents[doc_id]</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.nb_explore"><code class="name flex">
<span>def <span class="ident">nb_explore</span></span>(<span>self, doc_sort_key=None, reverse=False, display_fn=None, max_display_length=50000, metadata_full_doc_link='filename')</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function that creates an interactive Jupyter notebook widget for
exploring the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects tracked by this <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> or <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code>.</p>
<p><code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects do not have any sort order imposed on them by default,
but a custom sorting function can be passed via <code>doc_sort_key</code> if necessary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>doc_sort_key</code></strong> :&ensp;<code>fn</code>, optional</dt>
<dd>If specified, will sort <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects using this key when displaying
them.</dd>
<dt><strong><code>reverse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Reverses the sort direction for <code>doc_sort_key</code>, if specified.</dd>
<dt><strong><code>display_fn</code></strong> :&ensp;<code>fn</code>, optional</dt>
<dd>
<p>Custom display function that receives an individual <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> as input,
and should display the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> in human-readable form as a side effect.</p>
<p>If unset, will assume that the human-readable representation of the
<code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> is in HTML format and display it accordingly.</p>
</dd>
<dt><strong><code>max_display_length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>
<p>Maximum length (in characters) to display from the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> object's
human-readable representation.
If the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> object's human-readable
representation is longer than this limit, a link will be generated to
view the full human-readable representation in a new window.</p>
<p>No effect if <code>display_fn</code> is set.</p>
</dd>
<dt><strong><code>metadata_full_doc_link</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>If <code>max_display_length</code> is exceeded, this key is used to get the path to
the full human-readable representation from the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> object's
metadata dictionary.</p>
<p>No effect if <code>display_fn</code> is set.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nb_explore(
    self,
    doc_sort_key=None,
    reverse=False,
    display_fn=None,
    max_display_length=50000,
    metadata_full_doc_link=&#34;filename&#34;,
):
    &#34;&#34;&#34;
    Convenience function that creates an interactive Jupyter notebook widget for
    exploring the `Document` objects tracked by this `Corpus` or `CorpusSlice`.

    `Document` objects do not have any sort order imposed on them by default,
    but a custom sorting function can be passed via `doc_sort_key` if necessary.

    Parameters
    ----------
    doc_sort_key: fn, optional
        If specified, will sort `Document` objects using this key when displaying
        them.
    reverse: bool, optional
        Reverses the sort direction for `doc_sort_key`, if specified.
    display_fn: fn, optional
        Custom display function that receives an individual `Document` as input,
        and should display the `Document` in human-readable form as a side effect.

        If unset, will assume that the human-readable representation of the
        `Document` is in HTML format and display it accordingly.
    max_display_length: int, optional
        Maximum length (in characters) to display from the `Document` object&#39;s
        human-readable representation.  If the `Document` object&#39;s human-readable
        representation is longer than this limit, a link will be generated to
        view the full human-readable representation in a new window.

        No effect if `display_fn` is set.
    metadata_full_doc_link: str, optional
        If `max_display_length` is exceeded, this key is used to get the path to
        the full human-readable representation from the `Document` object&#39;s
        metadata dictionary.

        No effect if `display_fn` is set.
    &#34;&#34;&#34;
    import ipywidgets
    from IPython.core.display import display, HTML
    import ignis.util.jupyter_styles

    # Set up widget styling
    # noinspection PyTypeChecker
    display(HTML(ignis.util.jupyter_styles.jupyter_output_style))

    if len(self) == 0:
        print(&#34;This Corpus or CorpusSlice contains no documents.&#34;)
        return

    docs = list(self)

    if doc_sort_key is not None:
        docs = sorted(docs, key=doc_sort_key, reverse=reverse)

    def show_doc(index=1):
        # Start `index` from 1 for user-friendliness
        print(f&#34;[Total documents: {len(docs)}]\n&#34;)
        doc = docs[index - 1]

        if display_fn is None:
            # Default HTML display
            print(f&#34;ID: {doc.id}&#34;)
            if metadata_full_doc_link in doc.metadata:
                print(f&#34;Full document: {doc.metadata[metadata_full_doc_link]}&#34;)

            # Jupyter notebooks will interpret anything between $ signs as LaTeX
            # formulae when rendering HTML output, so we need to replace them
            # with escaped $ signs (only in Jupyter environments)
            display_str = doc.display_str.replace(&#34;$&#34;, r&#34;\$&#34;)

            # Length check
            if len(display_str) &gt; max_display_length:
                display_str = (
                    f&#34;&lt;p&gt;&#34;
                    f&#34;&lt;b&gt;Document too long to display in full - &#34;
                    f&#34;Showing first {max_display_length} characters.&lt;/b&gt;&#34;
                    f&#34;&lt;/p&gt;&#34;
                    f&#34;&lt;p&gt;&#34;
                    f&#34;&lt;a href=&#34;
                    f&#34;&#39;{doc.metadata[metadata_full_doc_link]}&#39; &#34;
                    f&#34;target=&#39;_blank&#39;&gt;&#34;
                    f&#34;Click here&#34;
                    f&#34;&lt;/a&gt; to open the full document in a new tab/window.&#34;
                    f&#34;&lt;/p&gt;&#34;
                    f&#34;&lt;hr/&gt;&#34; + display_str[:max_display_length]
                )

            # noinspection PyTypeChecker
            display(HTML(display_str))
        else:
            # User-provided display function
            display_fn(doc)

    # Control and output widgets for the document viewer
    slider = ipywidgets.IntSlider(
        description=&#34;Document&#34;,
        min=1,
        max=len(docs),
        continuous_update=False,
        layout=ignis.util.jupyter_styles.slider_layout,
        style=ignis.util.jupyter_styles.slider_style,
    )
    text = ipywidgets.BoundedIntText(
        min=1, max=len(docs), layout=ignis.util.jupyter_styles.slider_text_layout
    )
    ipywidgets.jslink((slider, &#34;value&#34;), (text, &#34;value&#34;))
    ui = ipywidgets.HBox([slider, text])
    out = ipywidgets.interactive_output(show_doc, {&#34;index&#34;: slider})
    # noinspection PyTypeChecker
    display(ui, out)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.remove_stop_word"><code class="name flex">
<span>def <span class="ident">remove_stop_word</span></span>(<span>self, stop_word)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the given stop word from the root <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> object's stop word list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stop_word</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_stop_word(self, stop_word):
    &#34;&#34;&#34;
    Remove the given stop word from the root `Corpus` object&#39;s stop word list.

    Parameters
    ----------
    stop_word: str
    &#34;&#34;&#34;
    if not isinstance(stop_word, str):
        raise RuntimeWarning(
            &#34;Use `.remove_stop_words()` to remove multiple stop words at once.&#34;
        )

    self.root.remove_stop_words([stop_word])</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.remove_stop_words"><code class="name flex">
<span>def <span class="ident">remove_stop_words</span></span>(<span>self, stop_words)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the given stop words from the root <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> object's stop word list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stop_words</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_stop_words(self, stop_words):
    &#34;&#34;&#34;
    Remove the given stop words from the root `Corpus` object&#39;s stop word list.

    Parameters
    ----------
    stop_words: iterable of str
    &#34;&#34;&#34;
    if isinstance(stop_words, str):
        raise RuntimeWarning(
            &#34;Use `.remove_stop_word()` to remove a single stop word.&#34;
        )

    for stop_word in stop_words:
        self.root._stop_words.remove(stop_word)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> or <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> object to the given file.
Essentially uses a bz2-compressed Pickle format.</p>
<p>We recommend using <em>.corpus</em> as the canonical file extension for <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>
objects and <em>.slice</em> as the canonical file extension for <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> objects,
but this is not strictly enforced by the library.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path</code></dt>
<dd>File to save the <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> or <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename):
    &#34;&#34;&#34;
    Saves the `Corpus` or `CorpusSlice` object to the given file.
    Essentially uses a bz2-compressed Pickle format.

    We recommend using _.corpus_ as the canonical file extension for `Corpus`
    objects and _.slice_ as the canonical file extension for `CorpusSlice` objects,
    but this is not strictly enforced by the library.

    Parameters
    ----------
    filename: str or pathlib.Path
        File to save the `Corpus` or `CorpusSlice` to.
    &#34;&#34;&#34;
    filename = pathlib.Path(filename)
    with bz2.open(filename, &#34;wb&#34;) as fp:
        pickle.dump(self, fp)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_by_ids"><code class="name flex">
<span>def <span class="ident">slice_by_ids</span></span>(<span>self, doc_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> with the given <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> IDs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>doc_ids</code></strong> :&ensp;<code>iterable</code> of <code>uuid.UUID</code> or <code>iterable</code> of <code>str</code></dt>
<dd>List of <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> IDs to include.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_ids(self, doc_ids):
    &#34;&#34;&#34;
    Create a new `CorpusSlice` with the given `Document` IDs.

    Parameters
    ----------
    doc_ids: iterable of uuid.UUID or iterable of str
        List of `Document` IDs to include.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    # Sanity check
    if isinstance(doc_ids, str) or isinstance(doc_ids, uuid.UUID):
        raise RuntimeWarning(
            &#34;`.slice_by_ids()` expects an iterable of Document IDs. If you are &#34;
            &#34;certain you want to create a slice containing a single Document, &#34;
            &#34;wrap it in a list or tuple before passing it as input.&#34;
        )

    # Make sure the IDs are in this instance&#39;s documents.
    for doc_id in doc_ids:
        if isinstance(doc_id, str):
            doc_id = uuid.UUID(doc_id)
        if doc_id not in self._documents:
            raise RuntimeError(
                f&#34;There is no `Document` with ID &#39;{str(doc_id)}&#39; within the &#34;
                f&#34;current slice.&#34;
            )

    return CorpusSlice(self.root, doc_ids)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_by_text_string"><code class="name flex">
<span>def <span class="ident">slice_by_text_string</span></span>(<span>self, text_string)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> with <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain the given
text string as an exact phrase match.</p>
<p>This method searches the <code>.plain_text</code> property of each <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
(case-insensitive). This is the full human-readable representation of the
<code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> as shown in the <code><a title="ignis.aurum.Aurum.nb_explore_topics" href="aurum.html#ignis.aurum.Aurum.nb_explore_topics">Aurum.nb_explore_topics()</a></code> or
<code><a title="ignis.corpus.Corpus.nb_explore" href="#ignis.corpus.Corpus.nb_explore">Corpus.nb_explore()</a></code> widgets.</p>
<p>Non-word characters at the boundaries of the text string are ignored, but any
punctuation marks or other characters <em>within</em> the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> text have to be
in the search string as well.</p>
<p>For example, the multi-word text string <code>"test this"</code> will match against a
<code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> with the phrase <code>"She said, 'Test this!'"</code>, but will <em>not</em> match
against a <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> with the phrase <code>"A test, this is."</code>, because of the
intervening comma.</p>
<p>To match both documents, you can perform an "OR" search on the individual
words using <code><a title="ignis.corpus.Corpus.slice_by_text_strings" href="#ignis.corpus.Corpus.slice_by_text_strings">Corpus.slice_by_text_strings()</a></code> instead:
<code>corpus_slice.slice_by_text_strings(["test", "this"])</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text_string</code></strong> :&ensp;<code>str</code></dt>
<dd>The text string to search the content of <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_text_string(self, text_string):
    &#34;&#34;&#34;
    Create a new `CorpusSlice` with `Document` objects that contain the given
    text string as an exact phrase match.

    This method searches the `.plain_text` property of each `Document`
    (case-insensitive). This is the full human-readable representation of the
    `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
    `Corpus.nb_explore()` widgets.

    Non-word characters at the boundaries of the text string are ignored, but any
    punctuation marks or other characters *within* the `Document` text have to be
    in the search string as well.

    For example, the multi-word text string `&#34;test this&#34;` will match against a
    `Document` with the phrase `&#34;She said, &#39;Test this!&#39;&#34;`, but will *not* match
    against a `Document` with the phrase `&#34;A test, this is.&#34;`, because of the
    intervening comma.

    To match both documents, you can perform an &#34;OR&#34; search on the individual
    words using `Corpus.slice_by_text_strings()` instead:
    `corpus_slice.slice_by_text_strings([&#34;test&#34;, &#34;this&#34;])`.

    Parameters
    ----------
    text_string: str
        The text string to search the content of `Document` objects for.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    if not isinstance(text_string, str):
        raise RuntimeWarning(
            &#34;Use `.slice_by_text_strings()` to slice by multiple text strings.&#34;
        )

    return self.slice_by_text_strings([text_string])</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_by_text_strings"><code class="name flex">
<span>def <span class="ident">slice_by_text_strings</span></span>(<span>self, text_strings)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> with <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain at least one of
the given text strings (an "OR" search).</p>
<p>This method searches the <code>.plain_text</code> property of each <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
(case-insensitive). This is the full human-readable representation of the
<code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> as shown in the <code><a title="ignis.aurum.Aurum.nb_explore_topics" href="aurum.html#ignis.aurum.Aurum.nb_explore_topics">Aurum.nb_explore_topics()</a></code> or
<code><a title="ignis.corpus.Corpus.nb_explore" href="#ignis.corpus.Corpus.nb_explore">Corpus.nb_explore()</a></code> widgets.</p>
<p>Non-word characters at the boundaries of each text string are ignored.</p>
<p>To slice together <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain multiple specific text
strings (an "AND" search), you can chain multiple invocations of the single
text string filter.
E.g.:
<code>corpus.slice_by_text_string("exact phrase").slice_by_text_string("another
exact phrase")</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text_strings</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>A list of the text strings to search the content of <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_text_strings(self, text_strings):
    &#34;&#34;&#34;
    Create a new `CorpusSlice` with `Document` objects that contain at least one of
    the given text strings (an &#34;OR&#34; search).

    This method searches the `.plain_text` property of each `Document`
    (case-insensitive). This is the full human-readable representation of the
    `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
    `Corpus.nb_explore()` widgets.

    Non-word characters at the boundaries of each text string are ignored.

    To slice together `Document` objects that contain multiple specific text
    strings (an &#34;AND&#34; search), you can chain multiple invocations of the single
    text string filter.
    E.g.:
    `corpus.slice_by_text_string(&#34;exact phrase&#34;).slice_by_text_string(&#34;another
    exact phrase&#34;)`.

    Parameters
    ----------
    text_strings: iterable of str
        A list of the text strings to search the content of `Document` objects for.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    # Sanity check
    if isinstance(text_strings, str):
        raise RuntimeWarning(
            &#34;Use `.slice_by_text_string()` to slice by a single text string.&#34;
        )

    # Plain-text search performs a regex text search, looking for `text_string`
    # matches that start/end on word boundaries.
    search_patterns = [
        re.compile(fr&#34;(\b|\s|^){re.escape(text_string)}(\b|\s|$)&#34;, re.IGNORECASE)
        for text_string in text_strings
    ]

    found_doc_ids = []
    for doc_id in self.document_ids:
        doc = self.get_document(doc_id)
        doc_text = doc.plain_text

        found_pattern = False
        for pattern in search_patterns:
            if pattern.search(doc_text):
                found_pattern = True
                break

        if found_pattern:
            found_doc_ids.append(doc_id)

    return self.slice_by_ids(found_doc_ids)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_by_token"><code class="name flex">
<span>def <span class="ident">slice_by_token</span></span>(<span>self, token)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> with <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain the given
token.</p>
<p>This method searches the <code>.tokens</code> property of each <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
(case-insensitive). These are the words and phrases that appear as labels in
the main graphical visualisation via <code><a title="ignis.aurum.Aurum.show_visualisation" href="aurum.html#ignis.aurum.Aurum.show_visualisation">Aurum.show_visualisation()</a></code>.</p>
<p>Note that each label is a single token even if it contains spaces/multiple
words.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code>str</code></dt>
<dd>The token to search <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_token(self, token):
    &#34;&#34;&#34;
    Create a new `CorpusSlice` with `Document` objects that contain the given
    token.

    This method searches the `.tokens` property of each `Document`
    (case-insensitive). These are the words and phrases that appear as labels in
    the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

    Note that each label is a single token even if it contains spaces/multiple
    words.

    Parameters
    ----------
    token: str
        The token to search `Document` objects for.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    if not isinstance(token, str):
        raise RuntimeWarning(
            &#34;Use `.slice_by_tokens()` to slice by multiple tokens at once.&#34;
        )

    return self.slice_by_tokens([token])</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_by_tokens"><code class="name flex">
<span>def <span class="ident">slice_by_tokens</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> with <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain at least one
of the given tokens (an "OR" search).</p>
<p>This method searches the <code>.tokens</code> property of each <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
(case-insensitive). These are the words and phrases that appear as labels in
the main graphical visualisation via <code><a title="ignis.aurum.Aurum.show_visualisation" href="aurum.html#ignis.aurum.Aurum.show_visualisation">Aurum.show_visualisation()</a></code>.</p>
<p>Note that each label is a single token even if it contains spaces/multiple
words.</p>
<p>To slice together <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain multiple specific tokens (an
"AND" search), you can chain multiple invocations of the single token filter.
E.g.:
<code>corpus.slice_by_token("token").slice_by_token("token 2")</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tokens</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>A list of the tokens to search <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_by_tokens(self, tokens):
    &#34;&#34;&#34;
    Create a new `CorpusSlice` with `Document` objects that contain at least one
    of the given tokens (an &#34;OR&#34; search).

    This method searches the `.tokens` property of each `Document`
    (case-insensitive). These are the words and phrases that appear as labels in
    the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

    Note that each label is a single token even if it contains spaces/multiple
    words.

    To slice together `Document` objects that contain multiple specific tokens (an
    &#34;AND&#34; search), you can chain multiple invocations of the single token filter.
    E.g.:
    `corpus.slice_by_token(&#34;token&#34;).slice_by_token(&#34;token 2&#34;)`.

    Parameters
    ----------
    tokens: iterable of str
        A list of the tokens to search `Document` objects for.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    # Sanity check
    if isinstance(tokens, str):
        raise RuntimeWarning(&#34;Use `.slice_by_token()` to slice by a single token.&#34;)

    # By-token search matches tokens directly, ignoring case
    search_tokens = set([token.lower() for token in tokens])

    found_doc_ids = []
    for doc_id in self.document_ids:
        doc = self.get_document(doc_id)
        doc_tokens = set([token.lower() for token in doc.tokens])
        if len(search_tokens &amp; doc_tokens) &gt; 0:
            found_doc_ids.append(doc_id)

    return self.slice_by_ids(found_doc_ids)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_filter"><code class="name flex">
<span>def <span class="ident">slice_filter</span></span>(<span>self, filter_fn)</span>
</code></dt>
<dd>
<div class="desc"><p>Slices using a custom <code>filter_fn</code> that receives one argument, a single
<code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>.</p>
<p>Returns a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> with the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that <code>filter_fn</code>
returns <code>True</code> for.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filter_fn</code></strong> :&ensp;<code>function</code></dt>
<dd>The filter function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_filter(self, filter_fn):
    &#34;&#34;&#34;
    Slices using a custom `filter_fn` that receives one argument, a single
    `Document`.

    Returns a new `CorpusSlice` with the `Document` objects that `filter_fn`
    returns `True` for.

    Parameters
    ----------
    filter_fn: function
        The filter function.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    filtered_doc_ids = []
    for doc_id in self.document_ids:
        doc = self.get_document(doc_id)
        if filter_fn(doc):
            filtered_doc_ids.append(doc_id)

    return self.slice_by_ids(filtered_doc_ids)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_full"><code class="name flex">
<span>def <span class="ident">slice_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> containing all the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects in this <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>.</p>
<p><strong>Note</strong>: This method can only be used with base <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> objects, and will
raise an error if used with a <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_full(self):
    &#34;&#34;&#34;
    Get a `CorpusSlice` containing all the `Document` objects in this `Corpus`.

    **Note**: This method can only be used with base `Corpus` objects, and will
    raise an error if used with a `CorpusSlice` object.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    return CorpusSlice(self, self.document_ids)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_without_text_string"><code class="name flex">
<span>def <span class="ident">slice_without_text_string</span></span>(<span>self, text_string)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> with <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain the given
text string removed.</p>
<p>This method searches the <code>.plain_text</code> property of each <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
(case-insensitive). This is the full human-readable representation of the
<code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> as shown in the <code><a title="ignis.aurum.Aurum.nb_explore_topics" href="aurum.html#ignis.aurum.Aurum.nb_explore_topics">Aurum.nb_explore_topics()</a></code> or
<code><a title="ignis.corpus.Corpus.nb_explore" href="#ignis.corpus.Corpus.nb_explore">Corpus.nb_explore()</a></code> widgets.</p>
<p>Non-word characters at the boundaries of the text string are ignored, but any
punctuation marks or other characters <em>within</em> the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> text have to be
in the search string as well.</p>
<p>For example, the multi-word text string <code>"test this"</code> will match against a
<code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> with the phrase <code>"She said, 'Test this!'"</code>, but will <em>not</em> match
against a <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> with the phrase <code>"A test, this is."</code>, because of the
intervening comma.</p>
<p>To match both documents, you can perform an "OR" search on the individual
words using <code><a title="ignis.corpus.Corpus.slice_without_text_strings" href="#ignis.corpus.Corpus.slice_without_text_strings">Corpus.slice_without_text_strings()</a></code> instead:
<code>corpus_slice.slice_without_text_strings(["test", "this"])</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text_string</code></strong> :&ensp;<code>str</code></dt>
<dd>The text string to search the content of <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_without_text_string(self, text_string):
    &#34;&#34;&#34;
    Create a new `CorpusSlice` with `Document` objects that contain the given
    text string removed.

    This method searches the `.plain_text` property of each `Document`
    (case-insensitive). This is the full human-readable representation of the
    `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
    `Corpus.nb_explore()` widgets.

    Non-word characters at the boundaries of the text string are ignored, but any
    punctuation marks or other characters *within* the `Document` text have to be
    in the search string as well.

    For example, the multi-word text string `&#34;test this&#34;` will match against a
    `Document` with the phrase `&#34;She said, &#39;Test this!&#39;&#34;`, but will *not* match
    against a `Document` with the phrase `&#34;A test, this is.&#34;`, because of the
    intervening comma.

    To match both documents, you can perform an &#34;OR&#34; search on the individual
    words using `Corpus.slice_without_text_strings()` instead:
    `corpus_slice.slice_without_text_strings([&#34;test&#34;, &#34;this&#34;])`.

    Parameters
    ----------
    text_string: str
        The text string to search the content of `Document` objects for.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    if not isinstance(text_string, str):
        raise RuntimeWarning(
            &#34;Use `.slice_without_text_strings()` to slice using multiple text &#34;
            &#34;strings at once.&#34;
        )

    return self.slice_without_text_strings([text_string])</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_without_text_strings"><code class="name flex">
<span>def <span class="ident">slice_without_text_strings</span></span>(<span>self, text_strings)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> by removing <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain any of
the given text strings (an "OR" search).</p>
<p>This method searches the <code>.plain_text</code> property of each <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
(case-insensitive). This is the full human-readable representation of the
<code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> as shown in the <code><a title="ignis.aurum.Aurum.nb_explore_topics" href="aurum.html#ignis.aurum.Aurum.nb_explore_topics">Aurum.nb_explore_topics()</a></code> or
<code><a title="ignis.corpus.Corpus.nb_explore" href="#ignis.corpus.Corpus.nb_explore">Corpus.nb_explore()</a></code> widgets.</p>
<p>Non-word characters at the boundaries of each text string are ignored.</p>
<p>To slice out <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain multiple specific text strings
(an "AND" search), you can chain multiple invocations of the single text string
filter.
E.g.:
<code>corpus.slice_without_text_string("exact phrase").slice_without_text_string(
"another exact phrase")</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text_strings</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>A list of the text strings to search the content of <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_without_text_strings(self, text_strings):
    &#34;&#34;&#34;
    Create a new `CorpusSlice` by removing `Document` objects that contain any of
    the given text strings (an &#34;OR&#34; search).

    This method searches the `.plain_text` property of each `Document`
    (case-insensitive). This is the full human-readable representation of the
    `Document` as shown in the `ignis.aurum.Aurum.nb_explore_topics()` or
    `Corpus.nb_explore()` widgets.

    Non-word characters at the boundaries of each text string are ignored.

    To slice out `Document` objects that contain multiple specific text strings
    (an &#34;AND&#34; search), you can chain multiple invocations of the single text string
    filter.
    E.g.:
    `corpus.slice_without_text_string(&#34;exact phrase&#34;).slice_without_text_string(
    &#34;another exact phrase&#34;)`.

    Parameters
    ----------
    text_strings: iterable of str
        A list of the text strings to search the content of `Document` objects for.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    # Sanity check
    if isinstance(text_strings, str):
        raise RuntimeWarning(
            &#34;Use `.slice_without_text_string()` to slice using a single text &#34;
            &#34;string.&#34;
        )

    # Plain-text search performs a regex text search, looking for `text_string`
    # matches that start/end on word boundaries or whitespace.
    search_patterns = [
        re.compile(fr&#34;(\b|\s|^){re.escape(text_string)}(\b|\s|$)&#34;, re.IGNORECASE)
        for text_string in text_strings
    ]

    found_doc_ids = []
    for doc_id in self.document_ids:
        doc = self.get_document(doc_id)
        doc_text = doc.plain_text

        found_pattern = False
        for pattern in search_patterns:
            if pattern.search(doc_text):
                found_pattern = True
                break

        if not found_pattern:
            found_doc_ids.append(doc_id)

    return self.slice_by_ids(found_doc_ids)</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_without_token"><code class="name flex">
<span>def <span class="ident">slice_without_token</span></span>(<span>self, token)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> by removing <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain the given
token.</p>
<p>This method searches the <code>.tokens</code> property of each <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
(case-insensitive). These are the words and phrases that appear as labels in
the main graphical visualisation via <code><a title="ignis.aurum.Aurum.show_visualisation" href="aurum.html#ignis.aurum.Aurum.show_visualisation">Aurum.show_visualisation()</a></code>.</p>
<p>Note that each label is a single token even if it contains spaces/multiple
words.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code>str</code></dt>
<dd>The token to search <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_without_token(self, token):
    &#34;&#34;&#34;
    Create a new `CorpusSlice` by removing `Document` objects that contain the given
    token.

    This method searches the `.tokens` property of each `Document`
    (case-insensitive). These are the words and phrases that appear as labels in
    the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

    Note that each label is a single token even if it contains spaces/multiple
    words.

    Parameters
    ----------
    token: str
        The token to search `Document` objects for.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    if not isinstance(token, str):
        raise RuntimeWarning(
            &#34;Use `.slice_without_tokens()` to slice using multiple tokens at once.&#34;
        )

    return self.slice_without_tokens([token])</code></pre>
</details>
</dd>
<dt id="ignis.corpus.Corpus.slice_without_tokens"><code class="name flex">
<span>def <span class="ident">slice_without_tokens</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> by removing <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain any of
the given tokens (an "OR" search).</p>
<p>This method searches the <code>.tokens</code> property of each <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
(case-insensitive). These are the words and phrases that appear as labels in
the main graphical visualisation via <code><a title="ignis.aurum.Aurum.show_visualisation" href="aurum.html#ignis.aurum.Aurum.show_visualisation">Aurum.show_visualisation()</a></code>.</p>
<p>Note that each label is a single token even if it contains spaces/multiple
words.</p>
<p>To slice out <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects that contain multiple specific tokens (an "AND"
search), you can chain multiple invocations of the single token filter.
E.g.:
<code>corpus.slice_without_token("token").slice_without_token("token 2")</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tokens</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>A list of the tokens to search <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_without_tokens(self, tokens):
    &#34;&#34;&#34;
    Create a new `CorpusSlice` by removing `Document` objects that contain any of
    the given tokens (an &#34;OR&#34; search).

    This method searches the `.tokens` property of each `Document`
    (case-insensitive). These are the words and phrases that appear as labels in
    the main graphical visualisation via `ignis.aurum.Aurum.show_visualisation()`.

    Note that each label is a single token even if it contains spaces/multiple
    words.

    To slice out `Document` objects that contain multiple specific tokens (an &#34;AND&#34;
    search), you can chain multiple invocations of the single token filter.
    E.g.:
    `corpus.slice_without_token(&#34;token&#34;).slice_without_token(&#34;token 2&#34;)`.

    Parameters
    ----------
    tokens: iterable of str
        A list of the tokens to search `Document` objects for.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    # Sanity check
    if isinstance(tokens, str):
        raise RuntimeWarning(
            &#34;Use `.slice_without_token()` to slice using a single token.&#34;
        )

    # By-token search matches tokens directly, ignoring case
    search_tokens = set([token.lower() for token in tokens])

    found_doc_ids = []
    for doc_id in self.document_ids:
        doc = self.get_document(doc_id)
        doc_tokens = set([token.lower() for token in doc.tokens])
        if len(search_tokens &amp; doc_tokens) == 0:
            found_doc_ids.append(doc_id)

    return self.slice_by_ids(found_doc_ids)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ignis.corpus.CorpusSlice"><code class="flex name class">
<span>class <span class="ident">CorpusSlice</span></span>
<span>(</span><span>root, slice_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains some subset of the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects in a <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>, and keeps a reference
to the root <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> for bookkeeping and iteration.</p>
<p>All the <code><a title="ignis" href="index.html">ignis</a></code> topic models take <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> objects as input.</p>
<p><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> is a subclass of <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>, so the same slicing methods can be used
with instances of both classes. To restart the slicing process from the full
base <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>, you can use the <code>.root</code> property of a <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> object.
(E.g., <code>corpus_slice.root.&lt;method&gt;()</code>.)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code></dt>
<dd>The root <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> instance for this slice.</dd>
<dt><strong><code>slice_ids</code></strong> :&ensp;<code>iterable</code> of <code>uuid.UUID</code> or <code>iterable</code> of <code>str</code></dt>
<dd>
<p>The IDs for the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects to include in this slice.</p>
<p>These are canonically instances of <code>uuid.UUID</code>, but a list of strings can
also be passed (e.g., when instantiating <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> objects interactively).</p>
</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code></dt>
<dd>A reference to the base <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> for bookkeeping and slicing/iteration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CorpusSlice(Corpus):
    &#34;&#34;&#34;
    Contains some subset of the `Document` objects in a `Corpus`, and keeps a reference
    to the root `Corpus` for bookkeeping and iteration.

    All the `ignis` topic models take `CorpusSlice` objects as input.

    `CorpusSlice` is a subclass of `Corpus`, so the same slicing methods can be used
    with instances of both classes. To restart the slicing process from the full
    base `Corpus`, you can use the `.root` property of a `CorpusSlice` object.
    (E.g., `corpus_slice.root.&lt;method&gt;()`.)

    Parameters
    ----------
    root: Corpus
        The root `Corpus` instance for this slice.
    slice_ids: iterable of uuid.UUID or iterable of str
        The IDs for the `Document` objects to include in this slice.

        These are canonically instances of `uuid.UUID`, but a list of strings can
        also be passed (e.g., when instantiating `CorpusSlice` objects interactively).

    Attributes
    ----------
    root: Corpus
        A reference to the base `Corpus` for bookkeeping and slicing/iteration.
    &#34;&#34;&#34;

    def __init__(self, root, slice_ids):
        super().__init__()

        self.root = root
        self._documents = collections.OrderedDict()

        slice_ids.sort()
        for slice_id in slice_ids:
            if isinstance(slice_id, str):
                slice_id = uuid.UUID(slice_id)
            self._documents[slice_id] = root.get_document(slice_id)

    def slice_full(self):
        # This method can only be used with base `Corpus` objects, and not
        # `CorpusSlice` objects.
        raise RuntimeError(
            &#34;The `.slice_full()` method can only be used with `Corpus` objects, &#34;
            &#34;not `CorpusSlice` objects.&#34;
        )

    def concat(self, *other_slices):
        &#34;&#34;&#34;
        Returns a new `CorpusSlice` that has the `Document` objects from this instance
        and all the other specified `CorpusSlice` objects combined.

        Only `CorpusSlice` objects with the same root `Corpus` can be concatenated.

        Note: The `+` operator can also be used to concatenate `CorpusSlice` objects.

        Parameters
        ----------
        *other_slices: iterable of CorpusSlice
            The other `CorpusSlice` object(s) to include.

        Returns
        -------
        CorpusSlice
        &#34;&#34;&#34;
        new_slice_ids = set(self.document_ids)

        for other_slice in other_slices:
            if not type(other_slice) is CorpusSlice:
                raise RuntimeError(
                    &#34;CorpusSlices can only be concatenated with other CorpusSlices.&#34;
                )

            if other_slice.root != self.root:
                raise RuntimeError(
                    &#34;CorpusSlices can only be concatenated if they have the same root &#34;
                    &#34;Corpus.&#34;
                )

            slice_ids = set(other_slice.document_ids)
            new_slice_ids = new_slice_ids | slice_ids

        new_slice_ids = list(new_slice_ids)

        return CorpusSlice(self.root, new_slice_ids)

    def __add__(self, other):
        return self.concat(other)

    def __eq__(self, other):
        return (
            type(other) is CorpusSlice
            and self.root == other.root
            and set(self.document_ids) == set(other.document_ids)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ignis.corpus.CorpusSlice.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>self, *other_slices)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> that has the <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects from this instance
and all the other specified <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> objects combined.</p>
<p>Only <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> objects with the same root <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> can be concatenated.</p>
<p>Note: The <code>+</code> operator can also be used to concatenate <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> objects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*other_slices</code></strong> :&ensp;<code>iterable</code> of <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>The other <code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code> object(s) to include.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(self, *other_slices):
    &#34;&#34;&#34;
    Returns a new `CorpusSlice` that has the `Document` objects from this instance
    and all the other specified `CorpusSlice` objects combined.

    Only `CorpusSlice` objects with the same root `Corpus` can be concatenated.

    Note: The `+` operator can also be used to concatenate `CorpusSlice` objects.

    Parameters
    ----------
    *other_slices: iterable of CorpusSlice
        The other `CorpusSlice` object(s) to include.

    Returns
    -------
    CorpusSlice
    &#34;&#34;&#34;
    new_slice_ids = set(self.document_ids)

    for other_slice in other_slices:
        if not type(other_slice) is CorpusSlice:
            raise RuntimeError(
                &#34;CorpusSlices can only be concatenated with other CorpusSlices.&#34;
            )

        if other_slice.root != self.root:
            raise RuntimeError(
                &#34;CorpusSlices can only be concatenated if they have the same root &#34;
                &#34;Corpus.&#34;
            )

        slice_ids = set(other_slice.document_ids)
        new_slice_ids = new_slice_ids | slice_ids

    new_slice_ids = list(new_slice_ids)

    return CorpusSlice(self.root, new_slice_ids)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></b></code>:
<ul class="hlist">
<li><code><a title="ignis.corpus.Corpus.add_doc" href="#ignis.corpus.Corpus.add_doc">add_doc</a></code></li>
<li><code><a title="ignis.corpus.Corpus.add_stop_word" href="#ignis.corpus.Corpus.add_stop_word">add_stop_word</a></code></li>
<li><code><a title="ignis.corpus.Corpus.add_stop_words" href="#ignis.corpus.Corpus.add_stop_words">add_stop_words</a></code></li>
<li><code><a title="ignis.corpus.Corpus.document_ids" href="#ignis.corpus.Corpus.document_ids">document_ids</a></code></li>
<li><code><a title="ignis.corpus.Corpus.get_document" href="#ignis.corpus.Corpus.get_document">get_document</a></code></li>
<li><code><a title="ignis.corpus.Corpus.nb_explore" href="#ignis.corpus.Corpus.nb_explore">nb_explore</a></code></li>
<li><code><a title="ignis.corpus.Corpus.remove_stop_word" href="#ignis.corpus.Corpus.remove_stop_word">remove_stop_word</a></code></li>
<li><code><a title="ignis.corpus.Corpus.remove_stop_words" href="#ignis.corpus.Corpus.remove_stop_words">remove_stop_words</a></code></li>
<li><code><a title="ignis.corpus.Corpus.save" href="#ignis.corpus.Corpus.save">save</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_ids" href="#ignis.corpus.Corpus.slice_by_ids">slice_by_ids</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_text_string" href="#ignis.corpus.Corpus.slice_by_text_string">slice_by_text_string</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_text_strings" href="#ignis.corpus.Corpus.slice_by_text_strings">slice_by_text_strings</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_token" href="#ignis.corpus.Corpus.slice_by_token">slice_by_token</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_tokens" href="#ignis.corpus.Corpus.slice_by_tokens">slice_by_tokens</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_filter" href="#ignis.corpus.Corpus.slice_filter">slice_filter</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_full" href="#ignis.corpus.Corpus.slice_full">slice_full</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_without_text_string" href="#ignis.corpus.Corpus.slice_without_text_string">slice_without_text_string</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_without_text_strings" href="#ignis.corpus.Corpus.slice_without_text_strings">slice_without_text_strings</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_without_token" href="#ignis.corpus.Corpus.slice_without_token">slice_without_token</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_without_tokens" href="#ignis.corpus.Corpus.slice_without_tokens">slice_without_tokens</a></code></li>
<li><code><a title="ignis.corpus.Corpus.stop_words" href="#ignis.corpus.Corpus.stop_words">stop_words</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ignis.corpus.Document"><code class="flex name class">
<span>class <span class="ident">Document</span></span>
<span>(</span><span>tokens, metadata, display_str, plain_text=None)</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> objects hold the textual content of each entry in the <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code>, as well
as any relevant metadata.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tokens</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>
<p>The individual content tokens in the given document, which will be fed
directly into the various topic modelling algorithms.</p>
<p>Assumed to have already undergone any necessary pre-processing except
stop word removal, which will be done at run-time whenever <code><a title="ignis.corpus.Document.tokens" href="#ignis.corpus.Document.tokens">Document.tokens</a></code> is
accessed.</p>
</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>A general-purpose dictionary containing any metadata the user wants to
track.</dd>
<dt><strong><code>display_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The content of the document, as a single string containing any necessary
markup or other formatting for human-readable display. By default,
<code>display_str</code> is assumed to contain a HTML representation of the document
(e.g., when the document is rendered in
<code><a title="ignis.aurum.Aurum.nb_explore_topics" href="aurum.html#ignis.aurum.Aurum.nb_explore_topics">Aurum.nb_explore_topics()</a></code>), but a custom display function can
be passed where necessary.</dd>
<dt><strong><code>plain_text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>The full text of the given document as a single normalised string.</p>
<p>If <code>plain_text</code> is None, <code>display_str</code> is assumed to contain a HTML
representation of the document, and a corresponding plain-text representation is
automatically generated via BeautifulSoup when the attribute is first accessed.</p>
</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>stop_words</code></strong> :&ensp;<code>set</code> of <code>str</code></dt>
<dd>The set of current stop words for this <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> object. When a <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> is
added to a <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> via <code><a title="ignis.corpus.Corpus.add_doc" href="#ignis.corpus.Corpus.add_doc">Corpus.add_doc()</a></code>, this becomes a reference to the
root <code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code> object's list of stop words.
Any items in this set of stop words will be removed when this <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code>
object's <code>tokens</code> property is accessed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Document(object):
    &#34;&#34;&#34;
    `Document` objects hold the textual content of each entry in the `Corpus`, as well
    as any relevant metadata.

    Parameters
    ----------
    tokens: iterable of str
        The individual content tokens in the given document, which will be fed
        directly into the various topic modelling algorithms.

        Assumed to have already undergone any necessary pre-processing except
        stop word removal, which will be done at run-time whenever `Document.tokens` is
        accessed.
    metadata: dict
        A general-purpose dictionary containing any metadata the user wants to
        track.
    display_str: str
        The content of the document, as a single string containing any necessary
        markup or other formatting for human-readable display. By default,
        `display_str` is assumed to contain a HTML representation of the document
        (e.g., when the document is rendered in
        `ignis.aurum.Aurum.nb_explore_topics()`), but a custom display function can
        be passed where necessary.
    plain_text: str, optional
        The full text of the given document as a single normalised string.

        If `plain_text` is None, `display_str` is assumed to contain a HTML
        representation of the document, and a corresponding plain-text representation is
        automatically generated via BeautifulSoup when the attribute is first accessed.

    Attributes
    ----------
    stop_words: set of str
        The set of current stop words for this `Document` object. When a `Document` is
        added to a `Corpus` via `Corpus.add_doc()`, this becomes a reference to the
        root `Corpus` object&#39;s list of stop words.
        Any items in this set of stop words will be removed when this `Document`
        object&#39;s `tokens` property is accessed.
    &#34;&#34;&#34;

    # Let&#39;s make Document IDs deterministic on their data, so that multiple runs of a
    # Corpus creation script don&#39;t generate different IDs.
    # We will create a UUID5 for each Document against this fixed namespace:
    ignis_uuid_namespace = uuid.UUID(&#34;58ca78f2-0347-4b96-b2e7-63796bf87889&#34;)
    &#34;&#34;&#34;The UUID5 namespace for generating deterministic `Document` IDs.&#34;&#34;&#34;

    def __init__(self, tokens, metadata, display_str, plain_text=None):
        self.raw_tokens = tokens
        self.metadata = metadata
        self.display_str = display_str
        self.plain_text = plain_text
        self.stop_words = set()

        data = f&#34;{tokens}{metadata}{display_str}&#34;
        self.id = uuid.uuid5(Document.ignis_uuid_namespace, data)

    def __setstate__(self, state):
        # Called when unpickling Document objects.
        # Ensure that `raw_tokens` is set properly when loading Corpus files saved
        # using the previous format (&lt; v1.5.0)
        if &#34;tokens&#34; in state and &#34;raw_tokens&#34; not in state:
            state[&#34;raw_tokens&#34;] = state[&#34;tokens&#34;]
        self.__dict__.update(state)

    @property
    def tokens(self):
        return [token for token in self.raw_tokens if token not in self.stop_words]

    def __str__(self):
        metadata = json.dumps(self.metadata, indent=2)

        truncated = []
        for line in metadata.splitlines():
            if len(line) &gt; 120:
                truncated.append(f&#34;{line[:120]}...&#34;)
            else:
                truncated.append(line)
        metadata = &#34;\n&#34;.join(truncated)

        return f&#34;ID: {self.id}\n\nMetadata: {metadata}\n\n&#34; f&#34;{self.display_str}&#34;

    def __getattribute__(self, item):
        if item == &#34;plain_text&#34; and object.__getattribute__(self, &#34;plain_text&#34;) is None:
            # There is no `plain_text` set for this document; assume that
            # `display_str` contains a HTML representation of the document.
            soup = BeautifulSoup(self.display_str, &#34;lxml&#34;)

            # The text returned by BeautifulSoup might contain whitespace --
            # Concatenate, split, and concatenate again to normalise the spacing
            self.plain_text = &#34; &#34;.join(soup.get_text().split())
            return self.plain_text
        return object.__getattribute__(self, item)

    def __repr__(self):
        return str(self)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="ignis.corpus.Document.ignis_uuid_namespace"><code class="name">var <span class="ident">ignis_uuid_namespace</span></code></dt>
<dd>
<div class="desc"><p>The UUID5 namespace for generating deterministic <code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code> IDs.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ignis.corpus.Document.tokens"><code class="name">var <span class="ident">tokens</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tokens(self):
    return [token for token in self.raw_tokens if token not in self.stop_words]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="padding: 1em 0.5em">
<a href="/ignis-tm/ignis">
<div style="display: flex; align-items: center">
<img src="/ignis-tm/images/logo.png" alt="Ignis" height="50"/>
<span style="font-size: 2em; font-weight: 700; margin-left: 0.75em">Ignis</span>
</div>
</a>
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ignis" href="index.html">ignis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ignis.corpus.load_corpus" href="#ignis.corpus.load_corpus">load_corpus</a></code></li>
<li><code><a title="ignis.corpus.load_slice" href="#ignis.corpus.load_slice">load_slice</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ignis.corpus.Corpus" href="#ignis.corpus.Corpus">Corpus</a></code></h4>
<ul class="">
<li><code><a title="ignis.corpus.Corpus.add_doc" href="#ignis.corpus.Corpus.add_doc">add_doc</a></code></li>
<li><code><a title="ignis.corpus.Corpus.add_stop_word" href="#ignis.corpus.Corpus.add_stop_word">add_stop_word</a></code></li>
<li><code><a title="ignis.corpus.Corpus.add_stop_words" href="#ignis.corpus.Corpus.add_stop_words">add_stop_words</a></code></li>
<li><code><a title="ignis.corpus.Corpus.concat" href="#ignis.corpus.Corpus.concat">concat</a></code></li>
<li><code><a title="ignis.corpus.Corpus.document_ids" href="#ignis.corpus.Corpus.document_ids">document_ids</a></code></li>
<li><code><a title="ignis.corpus.Corpus.get_document" href="#ignis.corpus.Corpus.get_document">get_document</a></code></li>
<li><code><a title="ignis.corpus.Corpus.nb_explore" href="#ignis.corpus.Corpus.nb_explore">nb_explore</a></code></li>
<li><code><a title="ignis.corpus.Corpus.remove_stop_word" href="#ignis.corpus.Corpus.remove_stop_word">remove_stop_word</a></code></li>
<li><code><a title="ignis.corpus.Corpus.remove_stop_words" href="#ignis.corpus.Corpus.remove_stop_words">remove_stop_words</a></code></li>
<li><code><a title="ignis.corpus.Corpus.save" href="#ignis.corpus.Corpus.save">save</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_ids" href="#ignis.corpus.Corpus.slice_by_ids">slice_by_ids</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_text_string" href="#ignis.corpus.Corpus.slice_by_text_string">slice_by_text_string</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_text_strings" href="#ignis.corpus.Corpus.slice_by_text_strings">slice_by_text_strings</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_token" href="#ignis.corpus.Corpus.slice_by_token">slice_by_token</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_by_tokens" href="#ignis.corpus.Corpus.slice_by_tokens">slice_by_tokens</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_filter" href="#ignis.corpus.Corpus.slice_filter">slice_filter</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_full" href="#ignis.corpus.Corpus.slice_full">slice_full</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_without_text_string" href="#ignis.corpus.Corpus.slice_without_text_string">slice_without_text_string</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_without_text_strings" href="#ignis.corpus.Corpus.slice_without_text_strings">slice_without_text_strings</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_without_token" href="#ignis.corpus.Corpus.slice_without_token">slice_without_token</a></code></li>
<li><code><a title="ignis.corpus.Corpus.slice_without_tokens" href="#ignis.corpus.Corpus.slice_without_tokens">slice_without_tokens</a></code></li>
<li><code><a title="ignis.corpus.Corpus.stop_words" href="#ignis.corpus.Corpus.stop_words">stop_words</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ignis.corpus.CorpusSlice" href="#ignis.corpus.CorpusSlice">CorpusSlice</a></code></h4>
<ul class="">
<li><code><a title="ignis.corpus.CorpusSlice.concat" href="#ignis.corpus.CorpusSlice.concat">concat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ignis.corpus.Document" href="#ignis.corpus.Document">Document</a></code></h4>
<ul class="">
<li><code><a title="ignis.corpus.Document.ignis_uuid_namespace" href="#ignis.corpus.Document.ignis_uuid_namespace">ignis_uuid_namespace</a></code></li>
<li><code><a title="ignis.corpus.Document.tokens" href="#ignis.corpus.Document.tokens">tokens</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>